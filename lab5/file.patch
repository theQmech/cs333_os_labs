diff -ruN xv6-orig/bio.c xv6-public/bio.c
--- xv6-orig/bio.c	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/bio.c	2016-09-25 15:51:45.647817076 +0530
@@ -4,7 +4,7 @@
 // cached copies of disk block contents.  Caching disk blocks
 // in memory reduces the number of disk reads and also provides
 // a synchronization point for disk blocks used by multiple processes.
-//
+// 
 // Interface:
 // * To get a buffer for a particular disk block, call bread.
 // * After changing buffer data, call bwrite to write it to disk.
@@ -12,8 +12,10 @@
 // * Do not use the buffer after calling brelse.
 // * Only one process at a time can use a buffer,
 //     so do not keep them longer than necessary.
-//
-// The implementation uses two state flags internally:
+// 
+// The implementation uses three state flags internally:
+// * B_BUSY: the block has been returned from bread
+//     and has not been passed back to brelse.  
 // * B_VALID: the buffer data has been read from the disk.
 // * B_DIRTY: the buffer data has been modified
 //     and needs to be written to disk.
@@ -22,7 +24,6 @@
 #include "defs.h"
 #include "param.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 
@@ -49,7 +50,7 @@
   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
     b->next = bcache.head.next;
     b->prev = &bcache.head;
-    initsleeplock(&b->lock, "buffer");
+    b->dev = -1;
     bcache.head.next->prev = b;
     bcache.head.next = b;
   }
@@ -57,7 +58,7 @@
 
 // Look through buffer cache for block on device dev.
 // If not found, allocate a buffer.
-// In either case, return locked buffer.
+// In either case, return B_BUSY buffer.
 static struct buf*
 bget(uint dev, uint blockno)
 {
@@ -65,34 +66,36 @@
 
   acquire(&bcache.lock);
 
+ loop:
   // Is the block already cached?
   for(b = bcache.head.next; b != &bcache.head; b = b->next){
     if(b->dev == dev && b->blockno == blockno){
-      b->refcnt++;
-      release(&bcache.lock);
-      acquiresleep(&b->lock);
-      return b;
+      if(!(b->flags & B_BUSY)){
+        b->flags |= B_BUSY;
+        release(&bcache.lock);
+        return b;
+      }
+      sleep(b, &bcache.lock);
+      goto loop;
     }
   }
 
-  // Not cached; recycle some unused buffer and clean buffer
-  // "clean" because B_DIRTY and not locked means log.c
+  // Not cached; recycle some non-busy and clean buffer.
+  // "clean" because B_DIRTY and !B_BUSY means log.c
   // hasn't yet committed the changes to the buffer.
   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
-    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+    if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
       b->dev = dev;
       b->blockno = blockno;
-      b->flags = 0;
-      b->refcnt = 1;
+      b->flags = B_BUSY;
       release(&bcache.lock);
-      acquiresleep(&b->lock);
       return b;
     }
   }
   panic("bget: no buffers");
 }
 
-// Return a locked buf with the contents of the indicated block.
+// Return a B_BUSY buf with the contents of the indicated block.
 struct buf*
 bread(uint dev, uint blockno)
 {
@@ -105,38 +108,36 @@
   return b;
 }
 
-// Write b's contents to disk.  Must be locked.
+// Write b's contents to disk.  Must be B_BUSY.
 void
 bwrite(struct buf *b)
 {
-  if(!holdingsleep(&b->lock))
+  if((b->flags & B_BUSY) == 0)
     panic("bwrite");
   b->flags |= B_DIRTY;
   iderw(b);
 }
 
-// Release a locked buffer.
+// Release a B_BUSY buffer.
 // Move to the head of the MRU list.
 void
 brelse(struct buf *b)
 {
-  if(!holdingsleep(&b->lock))
+  if((b->flags & B_BUSY) == 0)
     panic("brelse");
 
-  releasesleep(&b->lock);
-
   acquire(&bcache.lock);
-  b->refcnt--;
-  if (b->refcnt == 0) {
-    // no one is waiting for it.
-    b->next->prev = b->prev;
-    b->prev->next = b->next;
-    b->next = bcache.head.next;
-    b->prev = &bcache.head;
-    bcache.head.next->prev = b;
-    bcache.head.next = b;
-  }
-  
+
+  b->next->prev = b->prev;
+  b->prev->next = b->next;
+  b->next = bcache.head.next;
+  b->prev = &bcache.head;
+  bcache.head.next->prev = b;
+  bcache.head.next = b;
+
+  b->flags &= ~B_BUSY;
+  wakeup(b);
+
   release(&bcache.lock);
 }
 //PAGEBREAK!
diff -ruN xv6-orig/bootasm.S xv6-public/bootasm.S
--- xv6-orig/bootasm.S	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/bootasm.S	2016-09-25 15:51:45.647817076 +0530
@@ -45,7 +45,7 @@
   movl    %eax, %cr0
 
 //PAGEBREAK!
-  # Complete the transition to 32-bit protected mode by using a long jmp
+  # Complete transition to 32-bit protected mode by using long jmp
   # to reload %cs and %eip.  The segment descriptors are set up with no
   # translation, so that the mapping is still the identity mapping.
   ljmp    $(SEG_KCODE<<3), $start32
diff -ruN xv6-orig/bootmain.c xv6-public/bootmain.c
--- xv6-orig/bootmain.c	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/bootmain.c	2016-09-25 15:51:45.647817076 +0530
@@ -1,5 +1,5 @@
 // Boot loader.
-//
+// 
 // Part of the boot block, along with bootasm.S, which calls bootmain().
 // bootasm.S has put the processor into protected 32-bit mode.
 // bootmain() loads an ELF kernel image from the disk starting at
diff -ruN xv6-orig/buf.h xv6-public/buf.h
--- xv6-orig/buf.h	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/buf.h	2016-09-25 15:51:45.647817076 +0530
@@ -2,13 +2,12 @@
   int flags;
   uint dev;
   uint blockno;
-  struct sleeplock lock;
-  uint refcnt;
   struct buf *prev; // LRU cache list
   struct buf *next;
   struct buf *qnext; // disk queue
   uchar data[BSIZE];
 };
+#define B_BUSY  0x1  // buffer is locked by some process
 #define B_VALID 0x2  // buffer has been read from disk
 #define B_DIRTY 0x4  // buffer needs to be written to disk
 
diff -ruN xv6-orig/cat.c xv6-public/cat.c
--- xv6-orig/cat.c	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/cat.c	2016-09-25 15:51:45.647817076 +0530
@@ -9,12 +9,8 @@
 {
   int n;
 
-  while((n = read(fd, buf, sizeof(buf))) > 0) {
-    if (write(1, buf, n) != n) {
-      printf(1, "cat: write error\n");
-      exit();
-    }
-  }
+  while((n = read(fd, buf, sizeof(buf))) > 0)
+    write(1, buf, n);
   if(n < 0){
     printf(1, "cat: read error\n");
     exit();
diff -ruN xv6-orig/console.c xv6-public/console.c
--- xv6-orig/console.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/console.c	2016-09-25 20:36:57.807349991 +0530
@@ -7,7 +7,6 @@
 #include "param.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "file.h"
 #include "memlayout.h"
@@ -108,10 +107,10 @@
 {
   int i;
   uint pcs[10];
-
+  
   cli();
   cons.locking = 0;
-  cprintf("cpu with apicid %d: panic: ", cpu->apicid);
+  cprintf("cpu%d: panic: ", cpu->id);
   cprintf(s);
   cprintf("\n");
   getcallerpcs(&s, pcs);
@@ -131,7 +130,7 @@
 cgaputc(int c)
 {
   int pos;
-
+  
   // Cursor position: col + 80*row.
   outb(CRTPORT, 14);
   pos = inb(CRTPORT+1) << 8;
@@ -147,13 +146,13 @@
 
   if(pos < 0 || pos > 25*80)
     panic("pos under/overflow");
-
+  
   if((pos/80) >= 24){  // Scroll up.
     memmove(crt, crt+80, sizeof(crt[0])*23*80);
     pos -= 80;
     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
   }
-
+  
   outb(CRTPORT, 14);
   outb(CRTPORT+1, pos>>8);
   outb(CRTPORT, 15);
@@ -196,8 +195,7 @@
   while((c = getc()) >= 0){
     switch(c){
     case C('P'):  // Process listing.
-      // procdump() locks cons.lock indirectly; invoke later
-      doprocdump = 1;
+      doprocdump = 1;   // procdump() locks cons.lock indirectly; invoke later
       break;
     case C('U'):  // Kill line.
       while(input.e != input.w &&
diff -ruN xv6-orig/.cvsignore xv6-public/.cvsignore
--- xv6-orig/.cvsignore	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/.cvsignore	1970-01-01 05:30:00.000000000 +0530
@@ -1,16 +0,0 @@
-*.asm
-*.d
-*.sym
-_*
-kernel
-user1
-userfs
-usertests
-xv6.img
-vectors.S
-bochsout.txt
-bootblock
-bootother
-bootother.out
-parport.out
-fmt
diff -ruN xv6-orig/defs.h xv6-public/defs.h
--- xv6-orig/defs.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/defs.h	2016-09-25 17:54:12.571616538 +0530
@@ -6,7 +6,6 @@
 struct proc;
 struct rtcdate;
 struct spinlock;
-struct sleeplock;
 struct stat;
 struct superblock;
 
@@ -89,7 +88,9 @@
 
 // mp.c
 extern int      ismp;
+int             mpbcpu(void);
 void            mpinit(void);
+void            mpstartthem(void);
 
 // picirq.c
 void            picenable(int);
@@ -103,6 +104,7 @@
 
 //PAGEBREAK: 16
 // proc.c
+struct proc*    copyproc(struct proc*);
 void            exit(void);
 int             fork(void);
 int             growproc(int);
@@ -116,6 +118,7 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             setprio(int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -129,12 +132,6 @@
 void            pushcli(void);
 void            popcli(void);
 
-// sleeplock.c
-void            acquiresleep(struct sleeplock*);
-void             releasesleep(struct sleeplock*);
-int             holdingsleep(struct sleeplock*);
-void            initsleeplock(struct sleeplock*, char*);
-
 // string.c
 int             memcmp(const void*, const void*, uint);
 void*           memmove(void*, const void*, uint);
@@ -169,6 +166,7 @@
 // vm.c
 void            seginit(void);
 void            kvmalloc(void);
+void            vmenable(void);
 pde_t*          setupkvm(void);
 char*           uva2ka(pde_t*, char*);
 int             allocuvm(pde_t*, uint, uint);
diff -ruN xv6-orig/.dir-locals.el xv6-public/.dir-locals.el
--- xv6-orig/.dir-locals.el	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/.dir-locals.el	1970-01-01 05:30:00.000000000 +0530
@@ -1,4 +0,0 @@
-((c-mode
-  (indent-tabs-mode . nil)
-  (c-file-style . "bsd")
-  (c-basic-offset . 2)))
diff -ruN xv6-orig/elf.h xv6-public/elf.h
--- xv6-orig/elf.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/elf.h	2016-09-25 15:51:45.651817076 +0530
@@ -40,6 +40,3 @@
 #define ELF_PROG_FLAG_EXEC      1
 #define ELF_PROG_FLAG_WRITE     2
 #define ELF_PROG_FLAG_READ      4
-
-//PAGEBREAK!
-// Blank page.
diff -ruN xv6-orig/entryother.S xv6-public/entryother.S
--- xv6-orig/entryother.S	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/entryother.S	2016-09-25 15:51:45.651817076 +0530
@@ -17,49 +17,43 @@
 # place to jump to (mpenter) in start-8, and the physical address
 # of entrypgdir in start-12.
 #
-# This code combines elements of bootasm.S and entry.S.
+# This code is identical to bootasm.S except:
+#   - it does not need to enable A20
+#   - it uses the address at start-4, start-8, and start-12
 
 .code16           
 .globl start
 start:
   cli            
 
-  # Zero data segment registers DS, ES, and SS.
   xorw    %ax,%ax
   movw    %ax,%ds
   movw    %ax,%es
   movw    %ax,%ss
 
-  # Switch from real to protected mode.  Use a bootstrap GDT that makes
-  # virtual addresses map directly to physical addresses so that the
-  # effective memory map doesn't change during the transition.
   lgdt    gdtdesc
   movl    %cr0, %eax
   orl     $CR0_PE, %eax
   movl    %eax, %cr0
 
-  # Complete the transition to 32-bit protected mode by using a long jmp
-  # to reload %cs and %eip.  The segment descriptors are set up with no
-  # translation, so that the mapping is still the identity mapping.
+//PAGEBREAK!
   ljmpl    $(SEG_KCODE<<3), $(start32)
 
-//PAGEBREAK!
-.code32  # Tell assembler to generate 32-bit code now.
+.code32
 start32:
-  # Set up the protected-mode data segment registers
-  movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
-  movw    %ax, %ds                # -> DS: Data Segment
-  movw    %ax, %es                # -> ES: Extra Segment
-  movw    %ax, %ss                # -> SS: Stack Segment
-  movw    $0, %ax                 # Zero segments not ready for use
-  movw    %ax, %fs                # -> FS
-  movw    %ax, %gs                # -> GS
+  movw    $(SEG_KDATA<<3), %ax
+  movw    %ax, %ds
+  movw    %ax, %es
+  movw    %ax, %ss
+  movw    $0, %ax
+  movw    %ax, %fs
+  movw    %ax, %gs
 
   # Turn on page size extension for 4Mbyte pages
   movl    %cr4, %eax
   orl     $(CR4_PSE), %eax
   movl    %eax, %cr4
-  # Use entrypgdir as our initial page table
+  # Use enterpgdir as our initial page table
   movl    (start-12), %eax
   movl    %eax, %cr3
   # Turn on paging.
diff -ruN xv6-orig/entry.S xv6-public/entry.S
--- xv6-orig/entry.S	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/entry.S	2016-09-25 15:51:45.651817076 +0530
@@ -1,7 +1,3 @@
-# The xv6 kernel starts executing in this file. This file is linked with
-# the kernel C code, so it can refer to kernel symbols such as main().
-# The boot block (bootasm.S and bootmain.c) jumps to entry below.
-        
 # Multiboot header, for multiboot boot loaders like GNU Grub.
 # http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
 #
diff -ruN xv6-orig/exec.c xv6-public/exec.c
--- xv6-orig/exec.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/exec.c	2016-09-25 15:51:45.651817076 +0530
@@ -19,7 +19,6 @@
   pde_t *pgdir, *oldpgdir;
 
   begin_op();
-
   if((ip = namei(path)) == 0){
     end_op();
     return -1;
@@ -45,12 +44,8 @@
       continue;
     if(ph.memsz < ph.filesz)
       goto bad;
-    if(ph.vaddr + ph.memsz < ph.vaddr)
-      goto bad;
     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
       goto bad;
-    if(ph.vaddr % PGSIZE != 0)
-      goto bad;
     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
       goto bad;
   }
diff -ruN xv6-orig/file.c xv6-public/file.c
--- xv6-orig/file.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/file.c	2016-09-25 15:51:45.651817076 +0530
@@ -6,9 +6,8 @@
 #include "defs.h"
 #include "param.h"
 #include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
 #include "file.h"
+#include "spinlock.h"
 
 struct devsw devsw[NDEV];
 struct {
@@ -69,7 +68,7 @@
   f->ref = 0;
   f->type = FD_NONE;
   release(&ftable.lock);
-
+  
   if(ff.type == FD_PIPE)
     pipeclose(ff.pipe, ff.writable);
   else if(ff.type == FD_INODE){
diff -ruN xv6-orig/file.h xv6-public/file.h
--- xv6-orig/file.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/file.h	2016-09-25 15:51:45.651817076 +0530
@@ -14,8 +14,7 @@
   uint dev;           // Device number
   uint inum;          // Inode number
   int ref;            // Reference count
-  struct sleeplock lock;
-  int flags;          // I_VALID
+  int flags;          // I_BUSY, I_VALID
 
   short type;         // copy of disk inode
   short major;
@@ -24,6 +23,7 @@
   uint size;
   uint addrs[NDIRECT+1];
 };
+#define I_BUSY 0x1
 #define I_VALID 0x2
 
 // table mapping major device number to
diff -ruN xv6-orig/forktest.c xv6-public/forktest.c
--- xv6-orig/forktest.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/forktest.c	2016-09-25 18:40:14.567541148 +0530
@@ -27,24 +27,24 @@
     if(pid == 0)
       exit();
   }
-
+  
   if(n == N){
     printf(1, "fork claimed to work N times!\n", N);
     exit();
   }
-
+  
   for(; n > 0; n--){
     if(wait() < 0){
       printf(1, "wait stopped early\n");
       exit();
     }
   }
-
+  
   if(wait() != -1){
     printf(1, "wait got too many\n");
     exit();
   }
-
+  
   printf(1, "fork test OK\n");
 }
 
diff -ruN xv6-orig/fs.c xv6-public/fs.c
--- xv6-orig/fs.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/fs.c	2016-09-25 15:51:45.651817076 +0530
@@ -5,7 +5,7 @@
 //   + Directories: inode with special contents (list of other inodes!)
 //   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
 //
-// This file contains the low-level file system manipulation
+// This file contains the low-level file system manipulation 
 // routines.  The (higher-level) system call implementations
 // are in sysfile.c.
 
@@ -16,23 +16,20 @@
 #include "mmu.h"
 #include "proc.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 #include "file.h"
 
 #define min(a, b) ((a) < (b) ? (a) : (b))
 static void itrunc(struct inode*);
-// there should be one superblock per disk device, but we run with
-// only one device
-struct superblock sb; 
+struct superblock sb;   // there should be one per dev, but we run with one dev
 
 // Read the super block.
 void
 readsb(int dev, struct superblock *sb)
 {
   struct buf *bp;
-
+  
   bp = bread(dev, 1);
   memmove(sb, bp->data, sizeof(*sb));
   brelse(bp);
@@ -43,14 +40,14 @@
 bzero(int dev, int bno)
 {
   struct buf *bp;
-
+  
   bp = bread(dev, bno);
   memset(bp->data, 0, BSIZE);
   log_write(bp);
   brelse(bp);
 }
 
-// Blocks.
+// Blocks. 
 
 // Allocate a zeroed disk block.
 static uint
@@ -135,7 +132,9 @@
 //
 // * Locked: file system code may only examine and modify
 //   the information in an inode and its content if it
-//   has first locked the inode.
+//   has first locked the inode. The I_BUSY flag indicates
+//   that the inode is locked. ilock() sets I_BUSY,
+//   while iunlock clears it.
 //
 // Thus a typical sequence is:
 //   ip = iget(dev, inum)
@@ -163,18 +162,10 @@
 void
 iinit(int dev)
 {
-  int i = 0;
-  
   initlock(&icache.lock, "icache");
-  for(i = 0; i < NINODE; i++) {
-    initsleeplock(&icache.inode[i].lock, "inode");
-  }
-  
   readsb(dev, &sb);
-  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
- inodestart %d bmap start %d\n", sb.size, sb.nblocks,
-          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
-          sb.bmapstart);
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d inodestart %d bmap start %d\n", sb.size,
+          sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart, sb.bmapstart);
 }
 
 static struct inode* iget(uint dev, uint inum);
@@ -281,7 +272,11 @@
   if(ip == 0 || ip->ref < 1)
     panic("ilock");
 
-  acquiresleep(&ip->lock);
+  acquire(&icache.lock);
+  while(ip->flags & I_BUSY)
+    sleep(ip, &icache.lock);
+  ip->flags |= I_BUSY;
+  release(&icache.lock);
 
   if(!(ip->flags & I_VALID)){
     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
@@ -303,10 +298,13 @@
 void
 iunlock(struct inode *ip)
 {
-  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+  if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
     panic("iunlock");
 
-  releasesleep(&ip->lock);
+  acquire(&icache.lock);
+  ip->flags &= ~I_BUSY;
+  wakeup(ip);
+  release(&icache.lock);
 }
 
 // Drop a reference to an in-memory inode.
@@ -322,12 +320,16 @@
   acquire(&icache.lock);
   if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
     // inode has no links and no other references: truncate and free.
+    if(ip->flags & I_BUSY)
+      panic("iput busy");
+    ip->flags |= I_BUSY;
     release(&icache.lock);
     itrunc(ip);
     ip->type = 0;
     iupdate(ip);
     acquire(&icache.lock);
     ip->flags = 0;
+    wakeup(ip);
   }
   ip->ref--;
   release(&icache.lock);
@@ -346,7 +348,7 @@
 //
 // The content (data) associated with each inode is stored
 // in blocks on the disk. The first NDIRECT block numbers
-// are listed in ip->addrs[].  The next NINDIRECT blocks are
+// are listed in ip->addrs[].  The next NINDIRECT blocks are 
 // listed in block ip->addrs[NDIRECT].
 
 // Return the disk block address of the nth block in inode ip.
@@ -399,7 +401,7 @@
       ip->addrs[i] = 0;
     }
   }
-
+  
   if(ip->addrs[NDIRECT]){
     bp = bread(ip->dev, ip->addrs[NDIRECT]);
     a = (uint*)bp->data;
@@ -449,13 +451,6 @@
   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
     bp = bread(ip->dev, bmap(ip, off/BSIZE));
     m = min(n - tot, BSIZE - off%BSIZE);
-    /*
-    cprintf("data off %d:\n", off);
-    for (int j = 0; j < min(m, 10); j++) {
-      cprintf("%x ", bp->data[off%BSIZE+j]);
-    }
-    cprintf("\n");
-    */
     memmove(dst, bp->data + off%BSIZE, m);
     brelse(bp);
   }
@@ -559,7 +554,7 @@
   de.inum = inum;
   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
     panic("dirlink");
-
+  
   return 0;
 }
 
diff -ruN xv6-orig/fs.h xv6-public/fs.h
--- xv6-orig/fs.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/fs.h	2016-09-25 15:51:45.651817076 +0530
@@ -1,4 +1,4 @@
-// On-disk file system format.
+// On-disk file system format. 
 // Both the kernel and user programs use this header file.
 
 
@@ -6,11 +6,10 @@
 #define BSIZE 512  // block size
 
 // Disk layout:
-// [ boot block | super block | log | inode blocks |
-//                                          free bit map | data blocks]
+// [ boot block | super block | log | inode blocks | free bit map | data blocks ]
 //
-// mkfs computes the super block and builds an initial file system. The
-// super block describes the disk layout:
+// mkfs computes the super block and builds an initial file system. The super describes
+// the disk layout:
 struct superblock {
   uint size;         // Size of file system image (blocks)
   uint nblocks;      // Number of data blocks
diff -ruN xv6-orig/.gdbinit.tmpl xv6-public/.gdbinit.tmpl
--- xv6-orig/.gdbinit.tmpl	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/.gdbinit.tmpl	1970-01-01 05:30:00.000000000 +0530
@@ -1,27 +0,0 @@
-set $lastcs = -1
-
-define hook-stop
-  # There doesn't seem to be a good way to detect if we're in 16- or
-  # 32-bit mode, but in 32-bit mode we always run with CS == 8 in the
-  # kernel and CS == 35 in user space
-  if $cs == 8 || $cs == 35
-    if $lastcs != 8 && $lastcs != 35
-      set architecture i386
-    end
-    x/i $pc
-  else
-    if $lastcs == -1 || $lastcs == 8 || $lastcs == 35
-      set architecture i8086
-    end
-    # Translate the segment:offset into a physical address
-    printf "[%4x:%4x] ", $cs, $eip
-    x/i $cs*16+$eip
-  end
-  set $lastcs = $cs
-end
-
-echo + target remote localhost:1234\n
-target remote localhost:1234
-
-echo + symbol-file kernel\n
-symbol-file kernel
diff -ruN xv6-orig/getsize.c xv6-public/getsize.c
--- xv6-orig/getsize.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public/getsize.c	2016-09-25 15:51:45.651817076 +0530
@@ -0,0 +1,12 @@
+// A simple program which just prints something on screen
+
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(void)
+{
+ printf(1,"Here is ppid of process %d \n", getppid() );
+ exit();
+}
\ No newline at end of file
diff -ruN xv6-orig/.gitignore xv6-public/.gitignore
--- xv6-orig/.gitignore	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/.gitignore	1970-01-01 05:30:00.000000000 +0530
@@ -1,16 +0,0 @@
-*~
-_*
-*.o
-*.d
-*.asm
-*.sym
-*.img
-vectors.S
-bootblock
-entryother
-initcode
-initcode.out
-kernel
-kernelmemfs
-mkfs
-.gdbinit
diff -ruN xv6-orig/grep.c xv6-public/grep.c
--- xv6-orig/grep.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/grep.c	2016-09-25 15:51:45.651817076 +0530
@@ -12,7 +12,7 @@
 {
   int n, m;
   char *p, *q;
-
+  
   m = 0;
   while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
     m += n;
@@ -40,13 +40,13 @@
 {
   int fd, i;
   char *pattern;
-
+  
   if(argc <= 1){
     printf(2, "usage: grep pattern [file ...]\n");
     exit();
   }
   pattern = argv[1];
-
+  
   if(argc <= 2){
     grep(pattern, 0);
     exit();
diff -ruN xv6-orig/ide.c xv6-public/ide.c
--- xv6-orig/ide.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/ide.c	2016-09-25 15:51:45.651817076 +0530
@@ -9,7 +9,6 @@
 #include "x86.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 
@@ -21,8 +20,6 @@
 
 #define IDE_CMD_READ  0x20
 #define IDE_CMD_WRITE 0x30
-#define IDE_CMD_RDMUL 0xc4
-#define IDE_CMD_WRMUL 0xc5
 
 // idequeue points to the buf now being read/written to the disk.
 // idequeue->qnext points to the next buf to be processed.
@@ -40,7 +37,7 @@
 {
   int r;
 
-  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+  while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY) 
     ;
   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
     return -1;
@@ -51,12 +48,12 @@
 ideinit(void)
 {
   int i;
-
+  
   initlock(&idelock, "ide");
   picenable(IRQ_IDE);
   ioapicenable(IRQ_IDE, ncpu - 1);
   idewait(0);
-
+  
   // Check if disk 1 is present
   outb(0x1f6, 0xe0 | (1<<4));
   for(i=0; i<1000; i++){
@@ -65,7 +62,7 @@
       break;
     }
   }
-
+  
   // Switch back to disk 0.
   outb(0x1f6, 0xe0 | (0<<4));
 }
@@ -80,11 +77,9 @@
     panic("incorrect blockno");
   int sector_per_block =  BSIZE/SECTOR_SIZE;
   int sector = b->blockno * sector_per_block;
-  int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
-  int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
 
   if (sector_per_block > 7) panic("idestart");
-
+  
   idewait(0);
   outb(0x3f6, 0);  // generate interrupt
   outb(0x1f2, sector_per_block);  // number of sectors
@@ -93,10 +88,10 @@
   outb(0x1f5, (sector >> 16) & 0xff);
   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
   if(b->flags & B_DIRTY){
-    outb(0x1f7, write_cmd);
+    outb(0x1f7, IDE_CMD_WRITE);
     outsl(0x1f0, b->data, BSIZE/4);
   } else {
-    outb(0x1f7, read_cmd);
+    outb(0x1f7, IDE_CMD_READ);
   }
 }
 
@@ -118,12 +113,12 @@
   // Read data if needed.
   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
     insl(0x1f0, b->data, BSIZE/4);
-
+  
   // Wake process waiting for this buf.
   b->flags |= B_VALID;
   b->flags &= ~B_DIRTY;
   wakeup(b);
-
+  
   // Start disk on next buf in queue.
   if(idequeue != 0)
     idestart(idequeue);
@@ -132,7 +127,7 @@
 }
 
 //PAGEBREAK!
-// Sync buf with disk.
+// Sync buf with disk. 
 // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
 // Else if B_VALID is not set, read buf from disk, set B_VALID.
 void
@@ -140,8 +135,8 @@
 {
   struct buf **pp;
 
-  if(!holdingsleep(&b->lock))
-    panic("iderw: buf not locked");
+  if(!(b->flags & B_BUSY))
+    panic("iderw: buf not busy");
   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
     panic("iderw: nothing to do");
   if(b->dev != 0 && !havedisk1)
@@ -154,11 +149,11 @@
   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
     ;
   *pp = b;
-
+  
   // Start disk if necessary.
   if(idequeue == b)
     idestart(b);
-
+  
   // Wait for request to finish.
   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
     sleep(b, &idelock);
diff -ruN xv6-orig/initcode.S xv6-public/initcode.S
--- xv6-orig/initcode.S	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/initcode.S	2016-09-25 15:51:45.651817076 +0530
@@ -1,5 +1,4 @@
 # Initial process execs /init.
-# This code runs in user space.
 
 #include "syscall.h"
 #include "traps.h"
diff -ruN xv6-orig/ioapic.c xv6-public/ioapic.c
--- xv6-orig/ioapic.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/ioapic.c	2016-09-25 15:51:45.651817076 +0530
@@ -13,7 +13,7 @@
 #define REG_TABLE  0x10  // Redirection table base
 
 // The redirection table starts at REG_TABLE and uses
-// two registers to configure each interrupt.
+// two registers to configure each interrupt.  
 // The first (low) register in a pair contains configuration bits.
 // The second (high) register contains a bitmask telling which
 // CPUs can serve that interrupt.
diff -ruN xv6-orig/kalloc.c xv6-public/kalloc.c
--- xv6-orig/kalloc.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/kalloc.c	2016-09-25 15:51:45.651817076 +0530
@@ -61,7 +61,7 @@
 {
   struct run *r;
 
-  if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+  if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
     panic("kfree");
 
   // Fill with junk to catch dangling refs.
diff -ruN xv6-orig/lab5-patch xv6-public/lab5-patch
--- xv6-orig/lab5-patch	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public/lab5-patch	2016-09-25 21:06:38.383301390 +0530
@@ -0,0 +1,4624 @@
+diff -crB /home/rganvir/github/xv6-public/bio.c /home/rganvir/github/halfForce/lab5/xv6-public/bio.c
+*** /home/rganvir/github/xv6-public/bio.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/bio.c	2016-09-25 15:51:45.647817076 +0530
+***************
+*** 4,10 ****
+  // cached copies of disk block contents.  Caching disk blocks
+  // in memory reduces the number of disk reads and also provides
+  // a synchronization point for disk blocks used by multiple processes.
+! //
+  // Interface:
+  // * To get a buffer for a particular disk block, call bread.
+  // * After changing buffer data, call bwrite to write it to disk.
+--- 4,10 ----
+  // cached copies of disk block contents.  Caching disk blocks
+  // in memory reduces the number of disk reads and also provides
+  // a synchronization point for disk blocks used by multiple processes.
+! // 
+  // Interface:
+  // * To get a buffer for a particular disk block, call bread.
+  // * After changing buffer data, call bwrite to write it to disk.
+***************
+*** 12,19 ****
+  // * Do not use the buffer after calling brelse.
+  // * Only one process at a time can use a buffer,
+  //     so do not keep them longer than necessary.
+! //
+! // The implementation uses two state flags internally:
+  // * B_VALID: the buffer data has been read from the disk.
+  // * B_DIRTY: the buffer data has been modified
+  //     and needs to be written to disk.
+--- 12,21 ----
+  // * Do not use the buffer after calling brelse.
+  // * Only one process at a time can use a buffer,
+  //     so do not keep them longer than necessary.
+! // 
+! // The implementation uses three state flags internally:
+! // * B_BUSY: the block has been returned from bread
+! //     and has not been passed back to brelse.  
+  // * B_VALID: the buffer data has been read from the disk.
+  // * B_DIRTY: the buffer data has been modified
+  //     and needs to be written to disk.
+***************
+*** 22,28 ****
+  #include "defs.h"
+  #include "param.h"
+  #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "fs.h"
+  #include "buf.h"
+  
+--- 24,29 ----
+***************
+*** 49,55 ****
+    for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+      b->next = bcache.head.next;
+      b->prev = &bcache.head;
+!     initsleeplock(&b->lock, "buffer");
+      bcache.head.next->prev = b;
+      bcache.head.next = b;
+    }
+--- 50,56 ----
+    for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+      b->next = bcache.head.next;
+      b->prev = &bcache.head;
+!     b->dev = -1;
+      bcache.head.next->prev = b;
+      bcache.head.next = b;
+    }
+***************
+*** 57,63 ****
+  
+  // Look through buffer cache for block on device dev.
+  // If not found, allocate a buffer.
+! // In either case, return locked buffer.
+  static struct buf*
+  bget(uint dev, uint blockno)
+  {
+--- 58,64 ----
+  
+  // Look through buffer cache for block on device dev.
+  // If not found, allocate a buffer.
+! // In either case, return B_BUSY buffer.
+  static struct buf*
+  bget(uint dev, uint blockno)
+  {
+***************
+*** 65,98 ****
+  
+    acquire(&bcache.lock);
+  
+    // Is the block already cached?
+    for(b = bcache.head.next; b != &bcache.head; b = b->next){
+      if(b->dev == dev && b->blockno == blockno){
+!       b->refcnt++;
+!       release(&bcache.lock);
+!       acquiresleep(&b->lock);
+!       return b;
+      }
+    }
+  
+!   // Not cached; recycle some unused buffer and clean buffer
+!   // "clean" because B_DIRTY and not locked means log.c
+    // hasn't yet committed the changes to the buffer.
+    for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+!     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
+        b->dev = dev;
+        b->blockno = blockno;
+!       b->flags = 0;
+!       b->refcnt = 1;
+        release(&bcache.lock);
+-       acquiresleep(&b->lock);
+        return b;
+      }
+    }
+    panic("bget: no buffers");
+  }
+  
+! // Return a locked buf with the contents of the indicated block.
+  struct buf*
+  bread(uint dev, uint blockno)
+  {
+--- 66,101 ----
+  
+    acquire(&bcache.lock);
+  
++  loop:
+    // Is the block already cached?
+    for(b = bcache.head.next; b != &bcache.head; b = b->next){
+      if(b->dev == dev && b->blockno == blockno){
+!       if(!(b->flags & B_BUSY)){
+!         b->flags |= B_BUSY;
+!         release(&bcache.lock);
+!         return b;
+!       }
+!       sleep(b, &bcache.lock);
+!       goto loop;
+      }
+    }
+  
+!   // Not cached; recycle some non-busy and clean buffer.
+!   // "clean" because B_DIRTY and !B_BUSY means log.c
+    // hasn't yet committed the changes to the buffer.
+    for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+!     if((b->flags & B_BUSY) == 0 && (b->flags & B_DIRTY) == 0){
+        b->dev = dev;
+        b->blockno = blockno;
+!       b->flags = B_BUSY;
+        release(&bcache.lock);
+        return b;
+      }
+    }
+    panic("bget: no buffers");
+  }
+  
+! // Return a B_BUSY buf with the contents of the indicated block.
+  struct buf*
+  bread(uint dev, uint blockno)
+  {
+***************
+*** 105,142 ****
+    return b;
+  }
+  
+! // Write b's contents to disk.  Must be locked.
+  void
+  bwrite(struct buf *b)
+  {
+!   if(!holdingsleep(&b->lock))
+      panic("bwrite");
+    b->flags |= B_DIRTY;
+    iderw(b);
+  }
+  
+! // Release a locked buffer.
+  // Move to the head of the MRU list.
+  void
+  brelse(struct buf *b)
+  {
+!   if(!holdingsleep(&b->lock))
+      panic("brelse");
+  
+-   releasesleep(&b->lock);
+- 
+    acquire(&bcache.lock);
+!   b->refcnt--;
+!   if (b->refcnt == 0) {
+!     // no one is waiting for it.
+!     b->next->prev = b->prev;
+!     b->prev->next = b->next;
+!     b->next = bcache.head.next;
+!     b->prev = &bcache.head;
+!     bcache.head.next->prev = b;
+!     bcache.head.next = b;
+!   }
+!   
+    release(&bcache.lock);
+  }
+  //PAGEBREAK!
+--- 108,143 ----
+    return b;
+  }
+  
+! // Write b's contents to disk.  Must be B_BUSY.
+  void
+  bwrite(struct buf *b)
+  {
+!   if((b->flags & B_BUSY) == 0)
+      panic("bwrite");
+    b->flags |= B_DIRTY;
+    iderw(b);
+  }
+  
+! // Release a B_BUSY buffer.
+  // Move to the head of the MRU list.
+  void
+  brelse(struct buf *b)
+  {
+!   if((b->flags & B_BUSY) == 0)
+      panic("brelse");
+  
+    acquire(&bcache.lock);
+! 
+!   b->next->prev = b->prev;
+!   b->prev->next = b->next;
+!   b->next = bcache.head.next;
+!   b->prev = &bcache.head;
+!   bcache.head.next->prev = b;
+!   bcache.head.next = b;
+! 
+!   b->flags &= ~B_BUSY;
+!   wakeup(b);
+! 
+    release(&bcache.lock);
+  }
+  //PAGEBREAK!
+diff -crB /home/rganvir/github/xv6-public/bootasm.S /home/rganvir/github/halfForce/lab5/xv6-public/bootasm.S
+*** /home/rganvir/github/xv6-public/bootasm.S	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/bootasm.S	2016-09-25 15:51:45.647817076 +0530
+***************
+*** 45,51 ****
+    movl    %eax, %cr0
+  
+  //PAGEBREAK!
+!   # Complete the transition to 32-bit protected mode by using a long jmp
+    # to reload %cs and %eip.  The segment descriptors are set up with no
+    # translation, so that the mapping is still the identity mapping.
+    ljmp    $(SEG_KCODE<<3), $start32
+--- 45,51 ----
+    movl    %eax, %cr0
+  
+  //PAGEBREAK!
+!   # Complete transition to 32-bit protected mode by using long jmp
+    # to reload %cs and %eip.  The segment descriptors are set up with no
+    # translation, so that the mapping is still the identity mapping.
+    ljmp    $(SEG_KCODE<<3), $start32
+diff -crB /home/rganvir/github/xv6-public/bootmain.c /home/rganvir/github/halfForce/lab5/xv6-public/bootmain.c
+*** /home/rganvir/github/xv6-public/bootmain.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/bootmain.c	2016-09-25 15:51:45.647817076 +0530
+***************
+*** 1,5 ****
+  // Boot loader.
+! //
+  // Part of the boot block, along with bootasm.S, which calls bootmain().
+  // bootasm.S has put the processor into protected 32-bit mode.
+  // bootmain() loads an ELF kernel image from the disk starting at
+--- 1,5 ----
+  // Boot loader.
+! // 
+  // Part of the boot block, along with bootasm.S, which calls bootmain().
+  // bootasm.S has put the processor into protected 32-bit mode.
+  // bootmain() loads an ELF kernel image from the disk starting at
+diff -crB /home/rganvir/github/xv6-public/buf.h /home/rganvir/github/halfForce/lab5/xv6-public/buf.h
+*** /home/rganvir/github/xv6-public/buf.h	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/buf.h	2016-09-25 15:51:45.647817076 +0530
+***************
+*** 2,14 ****
+    int flags;
+    uint dev;
+    uint blockno;
+-   struct sleeplock lock;
+-   uint refcnt;
+    struct buf *prev; // LRU cache list
+    struct buf *next;
+    struct buf *qnext; // disk queue
+    uchar data[BSIZE];
+  };
+  #define B_VALID 0x2  // buffer has been read from disk
+  #define B_DIRTY 0x4  // buffer needs to be written to disk
+  
+--- 2,13 ----
+    int flags;
+    uint dev;
+    uint blockno;
+    struct buf *prev; // LRU cache list
+    struct buf *next;
+    struct buf *qnext; // disk queue
+    uchar data[BSIZE];
+  };
++ #define B_BUSY  0x1  // buffer is locked by some process
+  #define B_VALID 0x2  // buffer has been read from disk
+  #define B_DIRTY 0x4  // buffer needs to be written to disk
+  
+diff -crB /home/rganvir/github/xv6-public/cat.c /home/rganvir/github/halfForce/lab5/xv6-public/cat.c
+*** /home/rganvir/github/xv6-public/cat.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/cat.c	2016-09-25 15:51:45.647817076 +0530
+***************
+*** 9,20 ****
+  {
+    int n;
+  
+!   while((n = read(fd, buf, sizeof(buf))) > 0) {
+!     if (write(1, buf, n) != n) {
+!       printf(1, "cat: write error\n");
+!       exit();
+!     }
+!   }
+    if(n < 0){
+      printf(1, "cat: read error\n");
+      exit();
+--- 9,16 ----
+  {
+    int n;
+  
+!   while((n = read(fd, buf, sizeof(buf))) > 0)
+!     write(1, buf, n);
+    if(n < 0){
+      printf(1, "cat: read error\n");
+      exit();
+diff -crB /home/rganvir/github/xv6-public/console.c /home/rganvir/github/halfForce/lab5/xv6-public/console.c
+*** /home/rganvir/github/xv6-public/console.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/console.c	2016-09-25 20:36:57.807349991 +0530
+***************
+*** 7,13 ****
+  #include "param.h"
+  #include "traps.h"
+  #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "fs.h"
+  #include "file.h"
+  #include "memlayout.h"
+--- 7,12 ----
+***************
+*** 108,117 ****
+  {
+    int i;
+    uint pcs[10];
+! 
+    cli();
+    cons.locking = 0;
+!   cprintf("cpu with apicid %d: panic: ", cpu->apicid);
+    cprintf(s);
+    cprintf("\n");
+    getcallerpcs(&s, pcs);
+--- 107,116 ----
+  {
+    int i;
+    uint pcs[10];
+!   
+    cli();
+    cons.locking = 0;
+!   cprintf("cpu%d: panic: ", cpu->id);
+    cprintf(s);
+    cprintf("\n");
+    getcallerpcs(&s, pcs);
+***************
+*** 131,137 ****
+  cgaputc(int c)
+  {
+    int pos;
+! 
+    // Cursor position: col + 80*row.
+    outb(CRTPORT, 14);
+    pos = inb(CRTPORT+1) << 8;
+--- 130,136 ----
+  cgaputc(int c)
+  {
+    int pos;
+!   
+    // Cursor position: col + 80*row.
+    outb(CRTPORT, 14);
+    pos = inb(CRTPORT+1) << 8;
+***************
+*** 147,159 ****
+  
+    if(pos < 0 || pos > 25*80)
+      panic("pos under/overflow");
+! 
+    if((pos/80) >= 24){  // Scroll up.
+      memmove(crt, crt+80, sizeof(crt[0])*23*80);
+      pos -= 80;
+      memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+    }
+! 
+    outb(CRTPORT, 14);
+    outb(CRTPORT+1, pos>>8);
+    outb(CRTPORT, 15);
+--- 146,158 ----
+  
+    if(pos < 0 || pos > 25*80)
+      panic("pos under/overflow");
+!   
+    if((pos/80) >= 24){  // Scroll up.
+      memmove(crt, crt+80, sizeof(crt[0])*23*80);
+      pos -= 80;
+      memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
+    }
+!   
+    outb(CRTPORT, 14);
+    outb(CRTPORT+1, pos>>8);
+    outb(CRTPORT, 15);
+***************
+*** 196,203 ****
+    while((c = getc()) >= 0){
+      switch(c){
+      case C('P'):  // Process listing.
+!       // procdump() locks cons.lock indirectly; invoke later
+!       doprocdump = 1;
+        break;
+      case C('U'):  // Kill line.
+        while(input.e != input.w &&
+--- 195,201 ----
+    while((c = getc()) >= 0){
+      switch(c){
+      case C('P'):  // Process listing.
+!       doprocdump = 1;   // procdump() locks cons.lock indirectly; invoke later
+        break;
+      case C('U'):  // Kill line.
+        while(input.e != input.w &&
+Only in /home/rganvir/github/xv6-public/: .cvsignore
+diff -crB /home/rganvir/github/xv6-public/defs.h /home/rganvir/github/halfForce/lab5/xv6-public/defs.h
+*** /home/rganvir/github/xv6-public/defs.h	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/defs.h	2016-09-25 17:54:12.571616538 +0530
+***************
+*** 6,12 ****
+  struct proc;
+  struct rtcdate;
+  struct spinlock;
+- struct sleeplock;
+  struct stat;
+  struct superblock;
+  
+--- 6,11 ----
+***************
+*** 89,95 ****
+--- 88,96 ----
+  
+  // mp.c
+  extern int      ismp;
++ int             mpbcpu(void);
+  void            mpinit(void);
++ void            mpstartthem(void);
+  
+  // picirq.c
+  void            picenable(int);
+***************
+*** 103,108 ****
+--- 104,110 ----
+  
+  //PAGEBREAK: 16
+  // proc.c
++ struct proc*    copyproc(struct proc*);
+  void            exit(void);
+  int             fork(void);
+  int             growproc(int);
+***************
+*** 116,121 ****
+--- 118,124 ----
+  int             wait(void);
+  void            wakeup(void*);
+  void            yield(void);
++ int             setprio(int);
+  
+  // swtch.S
+  void            swtch(struct context**, struct context*);
+***************
+*** 129,140 ****
+  void            pushcli(void);
+  void            popcli(void);
+  
+- // sleeplock.c
+- void            acquiresleep(struct sleeplock*);
+- void             releasesleep(struct sleeplock*);
+- int             holdingsleep(struct sleeplock*);
+- void            initsleeplock(struct sleeplock*, char*);
+- 
+  // string.c
+  int             memcmp(const void*, const void*, uint);
+  void*           memmove(void*, const void*, uint);
+--- 132,137 ----
+***************
+*** 169,174 ****
+--- 166,172 ----
+  // vm.c
+  void            seginit(void);
+  void            kvmalloc(void);
++ void            vmenable(void);
+  pde_t*          setupkvm(void);
+  char*           uva2ka(pde_t*, char*);
+  int             allocuvm(pde_t*, uint, uint);
+Only in /home/rganvir/github/xv6-public/: .dir-locals.el
+diff -crB /home/rganvir/github/xv6-public/elf.h /home/rganvir/github/halfForce/lab5/xv6-public/elf.h
+*** /home/rganvir/github/xv6-public/elf.h	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/elf.h	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 40,45 ****
+  #define ELF_PROG_FLAG_EXEC      1
+  #define ELF_PROG_FLAG_WRITE     2
+  #define ELF_PROG_FLAG_READ      4
+- 
+- //PAGEBREAK!
+- // Blank page.
+--- 40,42 ----
+diff -crB /home/rganvir/github/xv6-public/entryother.S /home/rganvir/github/halfForce/lab5/xv6-public/entryother.S
+*** /home/rganvir/github/xv6-public/entryother.S	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/entryother.S	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 17,65 ****
+  # place to jump to (mpenter) in start-8, and the physical address
+  # of entrypgdir in start-12.
+  #
+! # This code combines elements of bootasm.S and entry.S.
+  
+  .code16           
+  .globl start
+  start:
+    cli            
+  
+-   # Zero data segment registers DS, ES, and SS.
+    xorw    %ax,%ax
+    movw    %ax,%ds
+    movw    %ax,%es
+    movw    %ax,%ss
+  
+-   # Switch from real to protected mode.  Use a bootstrap GDT that makes
+-   # virtual addresses map directly to physical addresses so that the
+-   # effective memory map doesn't change during the transition.
+    lgdt    gdtdesc
+    movl    %cr0, %eax
+    orl     $CR0_PE, %eax
+    movl    %eax, %cr0
+  
+!   # Complete the transition to 32-bit protected mode by using a long jmp
+!   # to reload %cs and %eip.  The segment descriptors are set up with no
+!   # translation, so that the mapping is still the identity mapping.
+    ljmpl    $(SEG_KCODE<<3), $(start32)
+  
+! //PAGEBREAK!
+! .code32  # Tell assembler to generate 32-bit code now.
+  start32:
+!   # Set up the protected-mode data segment registers
+!   movw    $(SEG_KDATA<<3), %ax    # Our data segment selector
+!   movw    %ax, %ds                # -> DS: Data Segment
+!   movw    %ax, %es                # -> ES: Extra Segment
+!   movw    %ax, %ss                # -> SS: Stack Segment
+!   movw    $0, %ax                 # Zero segments not ready for use
+!   movw    %ax, %fs                # -> FS
+!   movw    %ax, %gs                # -> GS
+  
+    # Turn on page size extension for 4Mbyte pages
+    movl    %cr4, %eax
+    orl     $(CR4_PSE), %eax
+    movl    %eax, %cr4
+!   # Use entrypgdir as our initial page table
+    movl    (start-12), %eax
+    movl    %eax, %cr3
+    # Turn on paging.
+--- 17,59 ----
+  # place to jump to (mpenter) in start-8, and the physical address
+  # of entrypgdir in start-12.
+  #
+! # This code is identical to bootasm.S except:
+! #   - it does not need to enable A20
+! #   - it uses the address at start-4, start-8, and start-12
+  
+  .code16           
+  .globl start
+  start:
+    cli            
+  
+    xorw    %ax,%ax
+    movw    %ax,%ds
+    movw    %ax,%es
+    movw    %ax,%ss
+  
+    lgdt    gdtdesc
+    movl    %cr0, %eax
+    orl     $CR0_PE, %eax
+    movl    %eax, %cr0
+  
+! //PAGEBREAK!
+    ljmpl    $(SEG_KCODE<<3), $(start32)
+  
+! .code32
+  start32:
+!   movw    $(SEG_KDATA<<3), %ax
+!   movw    %ax, %ds
+!   movw    %ax, %es
+!   movw    %ax, %ss
+!   movw    $0, %ax
+!   movw    %ax, %fs
+!   movw    %ax, %gs
+  
+    # Turn on page size extension for 4Mbyte pages
+    movl    %cr4, %eax
+    orl     $(CR4_PSE), %eax
+    movl    %eax, %cr4
+!   # Use enterpgdir as our initial page table
+    movl    (start-12), %eax
+    movl    %eax, %cr3
+    # Turn on paging.
+diff -crB /home/rganvir/github/xv6-public/entry.S /home/rganvir/github/halfForce/lab5/xv6-public/entry.S
+*** /home/rganvir/github/xv6-public/entry.S	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/entry.S	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 1,7 ****
+- # The xv6 kernel starts executing in this file. This file is linked with
+- # the kernel C code, so it can refer to kernel symbols such as main().
+- # The boot block (bootasm.S and bootmain.c) jumps to entry below.
+-         
+  # Multiboot header, for multiboot boot loaders like GNU Grub.
+  # http://www.gnu.org/software/grub/manual/multiboot/multiboot.html
+  #
+--- 1,3 ----
+diff -crB /home/rganvir/github/xv6-public/exec.c /home/rganvir/github/halfForce/lab5/xv6-public/exec.c
+*** /home/rganvir/github/xv6-public/exec.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/exec.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 45,56 ****
+        continue;
+      if(ph.memsz < ph.filesz)
+        goto bad;
+-     if(ph.vaddr + ph.memsz < ph.vaddr)
+-       goto bad;
+      if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
+        goto bad;
+-     if(ph.vaddr % PGSIZE != 0)
+-       goto bad;
+      if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
+        goto bad;
+    }
+--- 44,51 ----
+diff -crB /home/rganvir/github/xv6-public/file.c /home/rganvir/github/halfForce/lab5/xv6-public/file.c
+*** /home/rganvir/github/xv6-public/file.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/file.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 6,14 ****
+  #include "defs.h"
+  #include "param.h"
+  #include "fs.h"
+- #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "file.h"
+  
+  struct devsw devsw[NDEV];
+  struct {
+--- 6,13 ----
+  #include "defs.h"
+  #include "param.h"
+  #include "fs.h"
+  #include "file.h"
++ #include "spinlock.h"
+  
+  struct devsw devsw[NDEV];
+  struct {
+***************
+*** 69,75 ****
+    f->ref = 0;
+    f->type = FD_NONE;
+    release(&ftable.lock);
+! 
+    if(ff.type == FD_PIPE)
+      pipeclose(ff.pipe, ff.writable);
+    else if(ff.type == FD_INODE){
+--- 68,74 ----
+    f->ref = 0;
+    f->type = FD_NONE;
+    release(&ftable.lock);
+!   
+    if(ff.type == FD_PIPE)
+      pipeclose(ff.pipe, ff.writable);
+    else if(ff.type == FD_INODE){
+diff -crB /home/rganvir/github/xv6-public/file.h /home/rganvir/github/halfForce/lab5/xv6-public/file.h
+*** /home/rganvir/github/xv6-public/file.h	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/file.h	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 14,21 ****
+    uint dev;           // Device number
+    uint inum;          // Inode number
+    int ref;            // Reference count
+!   struct sleeplock lock;
+!   int flags;          // I_VALID
+  
+    short type;         // copy of disk inode
+    short major;
+--- 14,20 ----
+    uint dev;           // Device number
+    uint inum;          // Inode number
+    int ref;            // Reference count
+!   int flags;          // I_BUSY, I_VALID
+  
+    short type;         // copy of disk inode
+    short major;
+***************
+*** 24,29 ****
+--- 23,29 ----
+    uint size;
+    uint addrs[NDIRECT+1];
+  };
++ #define I_BUSY 0x1
+  #define I_VALID 0x2
+  
+  // table mapping major device number to
+Only in /home/rganvir/github/xv6-public/: fmt
+diff -crB /home/rganvir/github/xv6-public/forktest.c /home/rganvir/github/halfForce/lab5/xv6-public/forktest.c
+*** /home/rganvir/github/xv6-public/forktest.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/forktest.c	2016-09-25 18:40:14.567541148 +0530
+***************
+*** 27,50 ****
+      if(pid == 0)
+        exit();
+    }
+! 
+    if(n == N){
+      printf(1, "fork claimed to work N times!\n", N);
+      exit();
+    }
+! 
+    for(; n > 0; n--){
+      if(wait() < 0){
+        printf(1, "wait stopped early\n");
+        exit();
+      }
+    }
+! 
+    if(wait() != -1){
+      printf(1, "wait got too many\n");
+      exit();
+    }
+! 
+    printf(1, "fork test OK\n");
+  }
+  
+--- 27,50 ----
+      if(pid == 0)
+        exit();
+    }
+!   
+    if(n == N){
+      printf(1, "fork claimed to work N times!\n", N);
+      exit();
+    }
+!   
+    for(; n > 0; n--){
+      if(wait() < 0){
+        printf(1, "wait stopped early\n");
+        exit();
+      }
+    }
+!   
+    if(wait() != -1){
+      printf(1, "wait got too many\n");
+      exit();
+    }
+!   
+    printf(1, "fork test OK\n");
+  }
+  
+diff -crB /home/rganvir/github/xv6-public/fs.c /home/rganvir/github/halfForce/lab5/xv6-public/fs.c
+*** /home/rganvir/github/xv6-public/fs.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/fs.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 5,11 ****
+  //   + Directories: inode with special contents (list of other inodes!)
+  //   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
+  //
+! // This file contains the low-level file system manipulation
+  // routines.  The (higher-level) system call implementations
+  // are in sysfile.c.
+  
+--- 5,11 ----
+  //   + Directories: inode with special contents (list of other inodes!)
+  //   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
+  //
+! // This file contains the low-level file system manipulation 
+  // routines.  The (higher-level) system call implementations
+  // are in sysfile.c.
+  
+***************
+*** 16,38 ****
+  #include "mmu.h"
+  #include "proc.h"
+  #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "fs.h"
+  #include "buf.h"
+  #include "file.h"
+  
+  #define min(a, b) ((a) < (b) ? (a) : (b))
+  static void itrunc(struct inode*);
+! // there should be one superblock per disk device, but we run with
+! // only one device
+! struct superblock sb; 
+  
+  // Read the super block.
+  void
+  readsb(int dev, struct superblock *sb)
+  {
+    struct buf *bp;
+! 
+    bp = bread(dev, 1);
+    memmove(sb, bp->data, sizeof(*sb));
+    brelse(bp);
+--- 16,35 ----
+  #include "mmu.h"
+  #include "proc.h"
+  #include "spinlock.h"
+  #include "fs.h"
+  #include "buf.h"
+  #include "file.h"
+  
+  #define min(a, b) ((a) < (b) ? (a) : (b))
+  static void itrunc(struct inode*);
+! struct superblock sb;   // there should be one per dev, but we run with one dev
+  
+  // Read the super block.
+  void
+  readsb(int dev, struct superblock *sb)
+  {
+    struct buf *bp;
+!   
+    bp = bread(dev, 1);
+    memmove(sb, bp->data, sizeof(*sb));
+    brelse(bp);
+***************
+*** 43,56 ****
+  bzero(int dev, int bno)
+  {
+    struct buf *bp;
+! 
+    bp = bread(dev, bno);
+    memset(bp->data, 0, BSIZE);
+    log_write(bp);
+    brelse(bp);
+  }
+  
+! // Blocks.
+  
+  // Allocate a zeroed disk block.
+  static uint
+--- 40,53 ----
+  bzero(int dev, int bno)
+  {
+    struct buf *bp;
+!   
+    bp = bread(dev, bno);
+    memset(bp->data, 0, BSIZE);
+    log_write(bp);
+    brelse(bp);
+  }
+  
+! // Blocks. 
+  
+  // Allocate a zeroed disk block.
+  static uint
+***************
+*** 135,141 ****
+  //
+  // * Locked: file system code may only examine and modify
+  //   the information in an inode and its content if it
+! //   has first locked the inode.
+  //
+  // Thus a typical sequence is:
+  //   ip = iget(dev, inum)
+--- 132,140 ----
+  //
+  // * Locked: file system code may only examine and modify
+  //   the information in an inode and its content if it
+! //   has first locked the inode. The I_BUSY flag indicates
+! //   that the inode is locked. ilock() sets I_BUSY,
+! //   while iunlock clears it.
+  //
+  // Thus a typical sequence is:
+  //   ip = iget(dev, inum)
+***************
+*** 163,180 ****
+  void
+  iinit(int dev)
+  {
+-   int i = 0;
+-   
+    initlock(&icache.lock, "icache");
+-   for(i = 0; i < NINODE; i++) {
+-     initsleeplock(&icache.inode[i].lock, "inode");
+-   }
+-   
+    readsb(dev, &sb);
+!   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+!  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
+!           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
+!           sb.bmapstart);
+  }
+  
+  static struct inode* iget(uint dev, uint inum);
+--- 162,171 ----
+  void
+  iinit(int dev)
+  {
+    initlock(&icache.lock, "icache");
+    readsb(dev, &sb);
+!   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d inodestart %d bmap start %d\n", sb.size,
+!           sb.nblocks, sb.ninodes, sb.nlog, sb.logstart, sb.inodestart, sb.bmapstart);
+  }
+  
+  static struct inode* iget(uint dev, uint inum);
+***************
+*** 281,287 ****
+    if(ip == 0 || ip->ref < 1)
+      panic("ilock");
+  
+!   acquiresleep(&ip->lock);
+  
+    if(!(ip->flags & I_VALID)){
+      bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+--- 272,282 ----
+    if(ip == 0 || ip->ref < 1)
+      panic("ilock");
+  
+!   acquire(&icache.lock);
+!   while(ip->flags & I_BUSY)
+!     sleep(ip, &icache.lock);
+!   ip->flags |= I_BUSY;
+!   release(&icache.lock);
+  
+    if(!(ip->flags & I_VALID)){
+      bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+***************
+*** 303,312 ****
+  void
+  iunlock(struct inode *ip)
+  {
+!   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+      panic("iunlock");
+  
+!   releasesleep(&ip->lock);
+  }
+  
+  // Drop a reference to an in-memory inode.
+--- 298,310 ----
+  void
+  iunlock(struct inode *ip)
+  {
+!   if(ip == 0 || !(ip->flags & I_BUSY) || ip->ref < 1)
+      panic("iunlock");
+  
+!   acquire(&icache.lock);
+!   ip->flags &= ~I_BUSY;
+!   wakeup(ip);
+!   release(&icache.lock);
+  }
+  
+  // Drop a reference to an in-memory inode.
+***************
+*** 322,333 ****
+--- 320,335 ----
+    acquire(&icache.lock);
+    if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
+      // inode has no links and no other references: truncate and free.
++     if(ip->flags & I_BUSY)
++       panic("iput busy");
++     ip->flags |= I_BUSY;
+      release(&icache.lock);
+      itrunc(ip);
+      ip->type = 0;
+      iupdate(ip);
+      acquire(&icache.lock);
+      ip->flags = 0;
++     wakeup(ip);
+    }
+    ip->ref--;
+    release(&icache.lock);
+***************
+*** 346,352 ****
+  //
+  // The content (data) associated with each inode is stored
+  // in blocks on the disk. The first NDIRECT block numbers
+! // are listed in ip->addrs[].  The next NINDIRECT blocks are
+  // listed in block ip->addrs[NDIRECT].
+  
+  // Return the disk block address of the nth block in inode ip.
+--- 348,354 ----
+  //
+  // The content (data) associated with each inode is stored
+  // in blocks on the disk. The first NDIRECT block numbers
+! // are listed in ip->addrs[].  The next NINDIRECT blocks are 
+  // listed in block ip->addrs[NDIRECT].
+  
+  // Return the disk block address of the nth block in inode ip.
+***************
+*** 399,405 ****
+        ip->addrs[i] = 0;
+      }
+    }
+! 
+    if(ip->addrs[NDIRECT]){
+      bp = bread(ip->dev, ip->addrs[NDIRECT]);
+      a = (uint*)bp->data;
+--- 401,407 ----
+        ip->addrs[i] = 0;
+      }
+    }
+!   
+    if(ip->addrs[NDIRECT]){
+      bp = bread(ip->dev, ip->addrs[NDIRECT]);
+      a = (uint*)bp->data;
+***************
+*** 449,461 ****
+    for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+      bp = bread(ip->dev, bmap(ip, off/BSIZE));
+      m = min(n - tot, BSIZE - off%BSIZE);
+-     /*
+-     cprintf("data off %d:\n", off);
+-     for (int j = 0; j < min(m, 10); j++) {
+-       cprintf("%x ", bp->data[off%BSIZE+j]);
+-     }
+-     cprintf("\n");
+-     */
+      memmove(dst, bp->data + off%BSIZE, m);
+      brelse(bp);
+    }
+--- 451,456 ----
+***************
+*** 559,565 ****
+    de.inum = inum;
+    if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlink");
+! 
+    return 0;
+  }
+  
+--- 554,560 ----
+    de.inum = inum;
+    if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlink");
+!   
+    return 0;
+  }
+  
+diff -crB /home/rganvir/github/xv6-public/fs.h /home/rganvir/github/halfForce/lab5/xv6-public/fs.h
+*** /home/rganvir/github/xv6-public/fs.h	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/fs.h	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 1,4 ****
+! // On-disk file system format.
+  // Both the kernel and user programs use this header file.
+  
+  
+--- 1,4 ----
+! // On-disk file system format. 
+  // Both the kernel and user programs use this header file.
+  
+  
+***************
+*** 6,16 ****
+  #define BSIZE 512  // block size
+  
+  // Disk layout:
+! // [ boot block | super block | log | inode blocks |
+! //                                          free bit map | data blocks]
+  //
+! // mkfs computes the super block and builds an initial file system. The
+! // super block describes the disk layout:
+  struct superblock {
+    uint size;         // Size of file system image (blocks)
+    uint nblocks;      // Number of data blocks
+--- 6,15 ----
+  #define BSIZE 512  // block size
+  
+  // Disk layout:
+! // [ boot block | super block | log | inode blocks | free bit map | data blocks ]
+  //
+! // mkfs computes the super block and builds an initial file system. The super describes
+! // the disk layout:
+  struct superblock {
+    uint size;         // Size of file system image (blocks)
+    uint nblocks;      // Number of data blocks
+Only in /home/rganvir/github/xv6-public/: .gdbinit.tmpl
+Only in /home/rganvir/github/halfForce/lab5/xv6-public/: getsize.c
+Only in /home/rganvir/github/xv6-public/: .git
+Only in /home/rganvir/github/xv6-public/: .gitignore
+diff -crB /home/rganvir/github/xv6-public/grep.c /home/rganvir/github/halfForce/lab5/xv6-public/grep.c
+*** /home/rganvir/github/xv6-public/grep.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/grep.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 12,18 ****
+  {
+    int n, m;
+    char *p, *q;
+! 
+    m = 0;
+    while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+      m += n;
+--- 12,18 ----
+  {
+    int n, m;
+    char *p, *q;
+!   
+    m = 0;
+    while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+      m += n;
+***************
+*** 40,52 ****
+  {
+    int fd, i;
+    char *pattern;
+! 
+    if(argc <= 1){
+      printf(2, "usage: grep pattern [file ...]\n");
+      exit();
+    }
+    pattern = argv[1];
+! 
+    if(argc <= 2){
+      grep(pattern, 0);
+      exit();
+--- 40,52 ----
+  {
+    int fd, i;
+    char *pattern;
+!   
+    if(argc <= 1){
+      printf(2, "usage: grep pattern [file ...]\n");
+      exit();
+    }
+    pattern = argv[1];
+!   
+    if(argc <= 2){
+      grep(pattern, 0);
+      exit();
+diff -crB /home/rganvir/github/xv6-public/ide.c /home/rganvir/github/halfForce/lab5/xv6-public/ide.c
+*** /home/rganvir/github/xv6-public/ide.c	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/ide.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 9,15 ****
+  #include "x86.h"
+  #include "traps.h"
+  #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "fs.h"
+  #include "buf.h"
+  
+--- 9,14 ----
+***************
+*** 21,28 ****
+  
+  #define IDE_CMD_READ  0x20
+  #define IDE_CMD_WRITE 0x30
+- #define IDE_CMD_RDMUL 0xc4
+- #define IDE_CMD_WRMUL 0xc5
+  
+  // idequeue points to the buf now being read/written to the disk.
+  // idequeue->qnext points to the next buf to be processed.
+--- 20,25 ----
+***************
+*** 40,46 ****
+  {
+    int r;
+  
+!   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
+      ;
+    if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+      return -1;
+--- 37,43 ----
+  {
+    int r;
+  
+!   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY) 
+      ;
+    if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
+      return -1;
+***************
+*** 51,62 ****
+  ideinit(void)
+  {
+    int i;
+! 
+    initlock(&idelock, "ide");
+    picenable(IRQ_IDE);
+    ioapicenable(IRQ_IDE, ncpu - 1);
+    idewait(0);
+! 
+    // Check if disk 1 is present
+    outb(0x1f6, 0xe0 | (1<<4));
+    for(i=0; i<1000; i++){
+--- 48,59 ----
+  ideinit(void)
+  {
+    int i;
+!   
+    initlock(&idelock, "ide");
+    picenable(IRQ_IDE);
+    ioapicenable(IRQ_IDE, ncpu - 1);
+    idewait(0);
+!   
+    // Check if disk 1 is present
+    outb(0x1f6, 0xe0 | (1<<4));
+    for(i=0; i<1000; i++){
+***************
+*** 65,71 ****
+        break;
+      }
+    }
+! 
+    // Switch back to disk 0.
+    outb(0x1f6, 0xe0 | (0<<4));
+  }
+--- 62,68 ----
+        break;
+      }
+    }
+!   
+    // Switch back to disk 0.
+    outb(0x1f6, 0xe0 | (0<<4));
+  }
+***************
+*** 80,90 ****
+      panic("incorrect blockno");
+    int sector_per_block =  BSIZE/SECTOR_SIZE;
+    int sector = b->blockno * sector_per_block;
+-   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
+-   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
+  
+    if (sector_per_block > 7) panic("idestart");
+! 
+    idewait(0);
+    outb(0x3f6, 0);  // generate interrupt
+    outb(0x1f2, sector_per_block);  // number of sectors
+--- 77,85 ----
+      panic("incorrect blockno");
+    int sector_per_block =  BSIZE/SECTOR_SIZE;
+    int sector = b->blockno * sector_per_block;
+  
+    if (sector_per_block > 7) panic("idestart");
+!   
+    idewait(0);
+    outb(0x3f6, 0);  // generate interrupt
+    outb(0x1f2, sector_per_block);  // number of sectors
+***************
+*** 93,102 ****
+    outb(0x1f5, (sector >> 16) & 0xff);
+    outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+    if(b->flags & B_DIRTY){
+!     outb(0x1f7, write_cmd);
+      outsl(0x1f0, b->data, BSIZE/4);
+    } else {
+!     outb(0x1f7, read_cmd);
+    }
+  }
+  
+--- 88,97 ----
+    outb(0x1f5, (sector >> 16) & 0xff);
+    outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
+    if(b->flags & B_DIRTY){
+!     outb(0x1f7, IDE_CMD_WRITE);
+      outsl(0x1f0, b->data, BSIZE/4);
+    } else {
+!     outb(0x1f7, IDE_CMD_READ);
+    }
+  }
+  
+***************
+*** 118,129 ****
+    // Read data if needed.
+    if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+      insl(0x1f0, b->data, BSIZE/4);
+! 
+    // Wake process waiting for this buf.
+    b->flags |= B_VALID;
+    b->flags &= ~B_DIRTY;
+    wakeup(b);
+! 
+    // Start disk on next buf in queue.
+    if(idequeue != 0)
+      idestart(idequeue);
+--- 113,124 ----
+    // Read data if needed.
+    if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
+      insl(0x1f0, b->data, BSIZE/4);
+!   
+    // Wake process waiting for this buf.
+    b->flags |= B_VALID;
+    b->flags &= ~B_DIRTY;
+    wakeup(b);
+!   
+    // Start disk on next buf in queue.
+    if(idequeue != 0)
+      idestart(idequeue);
+***************
+*** 132,138 ****
+  }
+  
+  //PAGEBREAK!
+! // Sync buf with disk.
+  // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+  // Else if B_VALID is not set, read buf from disk, set B_VALID.
+  void
+--- 127,133 ----
+  }
+  
+  //PAGEBREAK!
+! // Sync buf with disk. 
+  // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+  // Else if B_VALID is not set, read buf from disk, set B_VALID.
+  void
+***************
+*** 140,147 ****
+  {
+    struct buf **pp;
+  
+!   if(!holdingsleep(&b->lock))
+!     panic("iderw: buf not locked");
+    if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+      panic("iderw: nothing to do");
+    if(b->dev != 0 && !havedisk1)
+--- 135,142 ----
+  {
+    struct buf **pp;
+  
+!   if(!(b->flags & B_BUSY))
+!     panic("iderw: buf not busy");
+    if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+      panic("iderw: nothing to do");
+    if(b->dev != 0 && !havedisk1)
+***************
+*** 154,164 ****
+    for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+      ;
+    *pp = b;
+! 
+    // Start disk if necessary.
+    if(idequeue == b)
+      idestart(b);
+! 
+    // Wait for request to finish.
+    while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+      sleep(b, &idelock);
+--- 149,159 ----
+    for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
+      ;
+    *pp = b;
+!   
+    // Start disk if necessary.
+    if(idequeue == b)
+      idestart(b);
+!   
+    // Wait for request to finish.
+    while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
+      sleep(b, &idelock);
+diff -crB /home/rganvir/github/xv6-public/initcode.S /home/rganvir/github/halfForce/lab5/xv6-public/initcode.S
+*** /home/rganvir/github/xv6-public/initcode.S	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/initcode.S	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 1,5 ****
+  # Initial process execs /init.
+- # This code runs in user space.
+  
+  #include "syscall.h"
+  #include "traps.h"
+--- 1,4 ----
+diff -crB /home/rganvir/github/xv6-public/ioapic.c /home/rganvir/github/halfForce/lab5/xv6-public/ioapic.c
+*** /home/rganvir/github/xv6-public/ioapic.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/ioapic.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 13,19 ****
+  #define REG_TABLE  0x10  // Redirection table base
+  
+  // The redirection table starts at REG_TABLE and uses
+! // two registers to configure each interrupt.
+  // The first (low) register in a pair contains configuration bits.
+  // The second (high) register contains a bitmask telling which
+  // CPUs can serve that interrupt.
+--- 13,19 ----
+  #define REG_TABLE  0x10  // Redirection table base
+  
+  // The redirection table starts at REG_TABLE and uses
+! // two registers to configure each interrupt.  
+  // The first (low) register in a pair contains configuration bits.
+  // The second (high) register contains a bitmask telling which
+  // CPUs can serve that interrupt.
+diff -crB /home/rganvir/github/xv6-public/kalloc.c /home/rganvir/github/halfForce/lab5/xv6-public/kalloc.c
+*** /home/rganvir/github/xv6-public/kalloc.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/kalloc.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 61,67 ****
+  {
+    struct run *r;
+  
+!   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
+      panic("kfree");
+  
+    // Fill with junk to catch dangling refs.
+--- 61,67 ----
+  {
+    struct run *r;
+  
+!   if((uint)v % PGSIZE || v < end || v2p(v) >= PHYSTOP)
+      panic("kfree");
+  
+    // Fill with junk to catch dangling refs.
+Only in /home/rganvir/github/halfForce/lab5/xv6-public/: lab5-patch
+diff -crB /home/rganvir/github/xv6-public/lapic.c /home/rganvir/github/halfForce/lab5/xv6-public/lapic.c
+*** /home/rganvir/github/xv6-public/lapic.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/lapic.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 1,7 ****
+  // The local APIC manages internal (non-I/O) interrupts.
+  // See Chapter 8 & Appendix C of Intel processor manual volume 3.
+  
+- #include "param.h"
+  #include "types.h"
+  #include "defs.h"
+  #include "date.h"
+--- 1,6 ----
+***************
+*** 9,15 ****
+  #include "traps.h"
+  #include "mmu.h"
+  #include "x86.h"
+- #include "proc.h"  // ncpu
+  
+  // Local APIC registers, divided by 4 for use as uint[] indices.
+  #define ID      (0x0020/4)   // ID
+--- 8,13 ----
+***************
+*** 55,73 ****
+  void
+  lapicinit(void)
+  {
+!   if(!lapic)
+      return;
+  
+    // Enable local APIC; set spurious interrupt vector.
+    lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
+  
+    // The timer repeatedly counts down at bus frequency
+!   // from lapic[TICR] and then issues an interrupt.
+    // If xv6 cared more about precise timekeeping,
+    // TICR would be calibrated using an external time source.
+    lapicw(TDCR, X1);
+    lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
+!   lapicw(TICR, 10000000);
+  
+    // Disable logical interrupt lines.
+    lapicw(LINT0, MASKED);
+--- 53,71 ----
+  void
+  lapicinit(void)
+  {
+!   if(!lapic) 
+      return;
+  
+    // Enable local APIC; set spurious interrupt vector.
+    lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
+  
+    // The timer repeatedly counts down at bus frequency
+!   // from lapic[TICR] and then issues an interrupt.  
+    // If xv6 cared more about precise timekeeping,
+    // TICR would be calibrated using an external time source.
+    lapicw(TDCR, X1);
+    lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
+!   lapicw(TICR, 10000000); 
+  
+    // Disable logical interrupt lines.
+    lapicw(LINT0, MASKED);
+***************
+*** 101,108 ****
+  int
+  cpunum(void)
+  {
+-   int apicid, i;
+-   
+    // Cannot call cpu when interrupts are enabled:
+    // result not guaranteed to last long enough to be used!
+    // Would prefer to panic but even printing is chancy here:
+--- 99,104 ----
+***************
+*** 115,129 ****
+          __builtin_return_address(0));
+    }
+  
+!   if (!lapic)
+!     return 0;
+! 
+!   apicid = lapic[ID] >> 24;
+!   for (i = 0; i < ncpu; ++i) {
+!     if (cpus[i].apicid == apicid)
+!       return i;
+!   }
+!   panic("unknown apicid\n");
+  }
+  
+  // Acknowledge interrupt.
+--- 111,119 ----
+          __builtin_return_address(0));
+    }
+  
+!   if(lapic)
+!     return lapic[ID]>>24;
+!   return 0;
+  }
+  
+  // Acknowledge interrupt.
+***************
+*** 151,157 ****
+  {
+    int i;
+    ushort *wrv;
+! 
+    // "The BSP must initialize CMOS shutdown code to 0AH
+    // and the warm reset vector (DWORD based at 40:67) to point at
+    // the AP startup code prior to the [universal startup algorithm]."
+--- 141,147 ----
+  {
+    int i;
+    ushort *wrv;
+!   
+    // "The BSP must initialize CMOS shutdown code to 0AH
+    // and the warm reset vector (DWORD based at 40:67) to point at
+    // the AP startup code prior to the [universal startup algorithm]."
+***************
+*** 168,174 ****
+    microdelay(200);
+    lapicw(ICRLO, INIT | LEVEL);
+    microdelay(100);    // should be 10ms, but too slow in Bochs!
+! 
+    // Send startup IPI (twice!) to enter code.
+    // Regular hardware is supposed to only accept a STARTUP
+    // when it is in the halted state due to an INIT.  So the second
+--- 158,164 ----
+    microdelay(200);
+    lapicw(ICRLO, INIT | LEVEL);
+    microdelay(100);    // should be 10ms, but too slow in Bochs!
+!   
+    // Send startup IPI (twice!) to enter code.
+    // Regular hardware is supposed to only accept a STARTUP
+    // when it is in the halted state due to an INIT.  So the second
+***************
+*** 221,237 ****
+    bcd = (sb & (1 << 2)) == 0;
+  
+    // make sure CMOS doesn't modify time while we read it
+!   for(;;) {
+      fill_rtcdate(&t1);
+!     if(cmos_read(CMOS_STATA) & CMOS_UIP)
+          continue;
+      fill_rtcdate(&t2);
+!     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+        break;
+    }
+  
+    // convert
+!   if(bcd) {
+  #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+      CONV(second);
+      CONV(minute);
+--- 211,227 ----
+    bcd = (sb & (1 << 2)) == 0;
+  
+    // make sure CMOS doesn't modify time while we read it
+!   for (;;) {
+      fill_rtcdate(&t1);
+!     if (cmos_read(CMOS_STATA) & CMOS_UIP)
+          continue;
+      fill_rtcdate(&t2);
+!     if (memcmp(&t1, &t2, sizeof(t1)) == 0)
+        break;
+    }
+  
+    // convert
+!   if (bcd) {
+  #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
+      CONV(second);
+      CONV(minute);
+diff -crB /home/rganvir/github/xv6-public/LICENSE /home/rganvir/github/halfForce/lab5/xv6-public/LICENSE
+*** /home/rganvir/github/xv6-public/LICENSE	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/LICENSE	2016-09-25 15:51:45.647817076 +0530
+***************
+*** 1,6 ****
+  The xv6 software is:
+  
+! Copyright (c) 2006-2016 Frans Kaashoek, Robert Morris, Russ Cox,
+                          Massachusetts Institute of Technology
+  
+  Permission is hereby granted, free of charge, to any person obtaining
+--- 1,6 ----
+  The xv6 software is:
+  
+! Copyright (c) 2006-2009 Frans Kaashoek, Robert Morris, Russ Cox,
+                          Massachusetts Institute of Technology
+  
+  Permission is hereby granted, free of charge, to any person obtaining
+diff -crB /home/rganvir/github/xv6-public/log.c /home/rganvir/github/halfForce/lab5/xv6-public/log.c
+*** /home/rganvir/github/xv6-public/log.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/log.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 2,8 ****
+  #include "defs.h"
+  #include "param.h"
+  #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "fs.h"
+  #include "buf.h"
+  
+--- 2,7 ----
+***************
+*** 32,38 ****
+  // Contents of the header block, used for both the on-disk header block
+  // and to keep track in memory of logged block# before commit.
+  struct logheader {
+!   int n;
+    int block[LOGSIZE];
+  };
+  
+--- 31,37 ----
+  // Contents of the header block, used for both the on-disk header block
+  // and to keep track in memory of logged block# before commit.
+  struct logheader {
+!   int n;   
+    int block[LOGSIZE];
+  };
+  
+***************
+*** 66,72 ****
+  }
+  
+  // Copy committed blocks from log to their home location
+! static void
+  install_trans(void)
+  {
+    int tail;
+--- 65,71 ----
+  }
+  
+  // Copy committed blocks from log to their home location
+! static void 
+  install_trans(void)
+  {
+    int tail;
+***************
+*** 76,82 ****
+      struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+      memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+      bwrite(dbuf);  // write dst to disk
+!     brelse(lbuf);
+      brelse(dbuf);
+    }
+  }
+--- 75,81 ----
+      struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+      memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+      bwrite(dbuf);  // write dst to disk
+!     brelse(lbuf); 
+      brelse(dbuf);
+    }
+  }
+***************
+*** 115,121 ****
+  static void
+  recover_from_log(void)
+  {
+!   read_head();
+    install_trans(); // if committed, copy from log to disk
+    log.lh.n = 0;
+    write_head(); // clear the log
+--- 114,120 ----
+  static void
+  recover_from_log(void)
+  {
+!   read_head();      
+    install_trans(); // if committed, copy from log to disk
+    log.lh.n = 0;
+    write_head(); // clear the log
+***************
+*** 172,178 ****
+  }
+  
+  // Copy modified blocks from cache to log.
+! static void
+  write_log(void)
+  {
+    int tail;
+--- 171,177 ----
+  }
+  
+  // Copy modified blocks from cache to log.
+! static void 
+  write_log(void)
+  {
+    int tail;
+***************
+*** 182,188 ****
+      struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+      memmove(to->data, from->data, BSIZE);
+      bwrite(to);  // write the log
+!     brelse(from);
+      brelse(to);
+    }
+  }
+--- 181,187 ----
+      struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+      memmove(to->data, from->data, BSIZE);
+      bwrite(to);  // write the log
+!     brelse(from); 
+      brelse(to);
+    }
+  }
+***************
+*** 194,200 ****
+      write_log();     // Write modified blocks from cache to log
+      write_head();    // Write header to disk -- the real commit
+      install_trans(); // Now install writes to home locations
+!     log.lh.n = 0;
+      write_head();    // Erase the transaction from the log
+    }
+  }
+--- 193,199 ----
+      write_log();     // Write modified blocks from cache to log
+      write_head();    // Write header to disk -- the real commit
+      install_trans(); // Now install writes to home locations
+!     log.lh.n = 0; 
+      write_head();    // Erase the transaction from the log
+    }
+  }
+diff -crB /home/rganvir/github/xv6-public/ls.c /home/rganvir/github/halfForce/lab5/xv6-public/ls.c
+*** /home/rganvir/github/xv6-public/ls.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/ls.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 8,19 ****
+  {
+    static char buf[DIRSIZ+1];
+    char *p;
+! 
+    // Find first character after last slash.
+    for(p=path+strlen(path); p >= path && *p != '/'; p--)
+      ;
+    p++;
+! 
+    // Return blank-padded name.
+    if(strlen(p) >= DIRSIZ)
+      return p;
+--- 8,19 ----
+  {
+    static char buf[DIRSIZ+1];
+    char *p;
+!   
+    // Find first character after last slash.
+    for(p=path+strlen(path); p >= path && *p != '/'; p--)
+      ;
+    p++;
+!   
+    // Return blank-padded name.
+    if(strlen(p) >= DIRSIZ)
+      return p;
+***************
+*** 29,51 ****
+    int fd;
+    struct dirent de;
+    struct stat st;
+! 
+    if((fd = open(path, 0)) < 0){
+      printf(2, "ls: cannot open %s\n", path);
+      return;
+    }
+! 
+    if(fstat(fd, &st) < 0){
+      printf(2, "ls: cannot stat %s\n", path);
+      close(fd);
+      return;
+    }
+! 
+    switch(st.type){
+    case T_FILE:
+      printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+      break;
+! 
+    case T_DIR:
+      if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+        printf(1, "ls: path too long\n");
+--- 29,51 ----
+    int fd;
+    struct dirent de;
+    struct stat st;
+!   
+    if((fd = open(path, 0)) < 0){
+      printf(2, "ls: cannot open %s\n", path);
+      return;
+    }
+!   
+    if(fstat(fd, &st) < 0){
+      printf(2, "ls: cannot stat %s\n", path);
+      close(fd);
+      return;
+    }
+!   
+    switch(st.type){
+    case T_FILE:
+      printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
+      break;
+!   
+    case T_DIR:
+      if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+        printf(1, "ls: path too long\n");
+Only in /home/rganvir/github/xv6-public/: LucidaSans-Typewriter83~
+diff -crB /home/rganvir/github/xv6-public/main.c /home/rganvir/github/halfForce/lab5/xv6-public/main.c
+*** /home/rganvir/github/xv6-public/main.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/main.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 19,31 ****
+  {
+    kinit1(end, P2V(4*1024*1024)); // phys page allocator
+    kvmalloc();      // kernel page table
+!   mpinit();        // detect other processors
+!   lapicinit();     // interrupt controller
+!   seginit();       // segment descriptors
+!   cprintf("\ncpu%d: starting xv6\n\n", cpunum());
+!   picinit();       // another interrupt controller
+    ioapicinit();    // another interrupt controller
+!   consoleinit();   // console hardware
+    uartinit();      // serial port
+    pinit();         // process table
+    tvinit();        // trap vectors
+--- 19,31 ----
+  {
+    kinit1(end, P2V(4*1024*1024)); // phys page allocator
+    kvmalloc();      // kernel page table
+!   mpinit();        // collect info about this machine
+!   lapicinit();
+!   seginit();       // set up segments
+!   cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
+!   picinit();       // interrupt controller
+    ioapicinit();    // another interrupt controller
+!   consoleinit();   // I/O devices & their interrupts
+    uartinit();      // serial port
+    pinit();         // process table
+    tvinit();        // trap vectors
+***************
+*** 37,50 ****
+    startothers();   // start other processors
+    kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+    userinit();      // first user process
+!   mpmain();        // finish this processor's setup
+  }
+  
+  // Other CPUs jump here from entryother.S.
+  static void
+  mpenter(void)
+  {
+!   switchkvm();
+    seginit();
+    lapicinit();
+    mpmain();
+--- 37,51 ----
+    startothers();   // start other processors
+    kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
+    userinit();      // first user process
+!   // Finish setting up this processor in mpmain.
+!   mpmain();
+  }
+  
+  // Other CPUs jump here from entryother.S.
+  static void
+  mpenter(void)
+  {
+!   switchkvm(); 
+    seginit();
+    lapicinit();
+    mpmain();
+***************
+*** 54,60 ****
+  static void
+  mpmain(void)
+  {
+!   cprintf("cpu%d: starting\n", cpunum());
+    idtinit();       // load idt register
+    xchg(&cpu->started, 1); // tell startothers() we're up
+    scheduler();     // start running processes
+--- 55,61 ----
+  static void
+  mpmain(void)
+  {
+!   cprintf("cpu%d: starting\n", cpu->id);
+    idtinit();       // load idt register
+    xchg(&cpu->started, 1); // tell startothers() we're up
+    scheduler();     // start running processes
+***************
+*** 74,95 ****
+    // Write entry code to unused memory at 0x7000.
+    // The linker has placed the image of entryother.S in
+    // _binary_entryother_start.
+!   code = P2V(0x7000);
+    memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+  
+    for(c = cpus; c < cpus+ncpu; c++){
+      if(c == cpus+cpunum())  // We've started already.
+        continue;
+  
+!     // Tell entryother.S what stack to use, where to enter, and what
+      // pgdir to use. We cannot use kpgdir yet, because the AP processor
+      // is running in low  memory, so we use entrypgdir for the APs too.
+      stack = kalloc();
+      *(void**)(code-4) = stack + KSTACKSIZE;
+      *(void**)(code-8) = mpenter;
+!     *(int**)(code-12) = (void *) V2P(entrypgdir);
+  
+!     lapicstartap(c->apicid, V2P(code));
+  
+      // wait for cpu to finish mpmain()
+      while(c->started == 0)
+--- 75,96 ----
+    // Write entry code to unused memory at 0x7000.
+    // The linker has placed the image of entryother.S in
+    // _binary_entryother_start.
+!   code = p2v(0x7000);
+    memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
+  
+    for(c = cpus; c < cpus+ncpu; c++){
+      if(c == cpus+cpunum())  // We've started already.
+        continue;
+  
+!     // Tell entryother.S what stack to use, where to enter, and what 
+      // pgdir to use. We cannot use kpgdir yet, because the AP processor
+      // is running in low  memory, so we use entrypgdir for the APs too.
+      stack = kalloc();
+      *(void**)(code-4) = stack + KSTACKSIZE;
+      *(void**)(code-8) = mpenter;
+!     *(int**)(code-12) = (void *) v2p(entrypgdir);
+  
+!     lapicstartap(c->id, v2p(code));
+  
+      // wait for cpu to finish mpmain()
+      while(c->started == 0)
+***************
+*** 97,107 ****
+    }
+  }
+  
+! // The boot page table used in entry.S and entryother.S.
+! // Page directories (and page tables) must start on page boundaries,
+! // hence the __aligned__ attribute.
+! // PTE_PS in a page directory entry enables 4Mbyte pages.
+! 
+  __attribute__((__aligned__(PGSIZE)))
+  pde_t entrypgdir[NPDENTRIES] = {
+    // Map VA's [0, 4MB) to PA's [0, 4MB)
+--- 98,107 ----
+    }
+  }
+  
+! // Boot page table used in entry.S and entryother.S.
+! // Page directories (and page tables), must start on a page boundary,
+! // hence the "__aligned__" attribute.  
+! // Use PTE_PS in page directory entry to enable 4Mbyte pages.
+  __attribute__((__aligned__(PGSIZE)))
+  pde_t entrypgdir[NPDENTRIES] = {
+    // Map VA's [0, 4MB) to PA's [0, 4MB)
+***************
+*** 113,115 ****
+--- 113,118 ----
+  //PAGEBREAK!
+  // Blank page.
+  //PAGEBREAK!
++ // Blank page.
++ //PAGEBREAK!
++ // Blank page.
+diff -crB /home/rganvir/github/xv6-public/Makefile /home/rganvir/github/halfForce/lab5/xv6-public/Makefile
+*** /home/rganvir/github/xv6-public/Makefile	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/Makefile	2016-09-25 19:34:38.431452059 +0530
+***************
+*** 15,21 ****
+  	picirq.o\
+  	pipe.o\
+  	proc.o\
+- 	sleeplock.o\
+  	spinlock.o\
+  	string.o\
+  	swtch.o\
+--- 15,20 ----
+***************
+*** 75,82 ****
+  LD = $(TOOLPREFIX)ld
+  OBJCOPY = $(TOOLPREFIX)objcopy
+  OBJDUMP = $(TOOLPREFIX)objdump
+! CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+! #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+  CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+  ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+  # FreeBSD ld wants ``elf_i386_fbsd''
+--- 74,81 ----
+  LD = $(TOOLPREFIX)ld
+  OBJCOPY = $(TOOLPREFIX)objcopy
+  OBJDUMP = $(TOOLPREFIX)objdump
+! #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+! CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+  CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+  ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+  # FreeBSD ld wants ``elf_i386_fbsd''
+***************
+*** 173,178 ****
+--- 172,179 ----
+  	_usertests\
+  	_wc\
+  	_zombie\
++ 	_getsize\
++ 	_testschd\
+  
+  fs.img: mkfs README $(UPROGS)
+  	./mkfs fs.img README $(UPROGS)
+***************
+*** 186,191 ****
+--- 187,195 ----
+  	.gdbinit \
+  	$(UPROGS)
+  
++ simulate:
++ 	qemu-system-i386 -serial mon:stdio -hdb fs.img xv6.img -smp cores=4 -m 512
++ 
+  # make a printout
+  FILES = $(shell grep -v '^\#' runoff.list)
+  PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
+***************
+*** 211,223 ****
+  ifndef CPUS
+  CPUS := 2
+  endif
+! QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+  
+  qemu: fs.img xv6.img
+  	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+  
+  qemu-memfs: xv6memfs.img
+! 	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+  
+  qemu-nox: fs.img xv6.img
+  	$(QEMU) -nographic $(QEMUOPTS)
+--- 215,227 ----
+  ifndef CPUS
+  CPUS := 2
+  endif
+! QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)
+  
+  qemu: fs.img xv6.img
+  	$(QEMU) -serial mon:stdio $(QEMUOPTS)
+  
+  qemu-memfs: xv6memfs.img
+! 	$(QEMU) xv6memfs.img -smp $(CPUS) -m 256
+  
+  qemu-nox: fs.img xv6.img
+  	$(QEMU) -nographic $(QEMUOPTS)
+***************
+*** 240,247 ****
+  # check in that version.
+  
+  EXTRA=\
+! 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
+! 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+  	printf.c umalloc.c\
+  	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+  	.gdbinit.tmpl gdbutil\
+--- 244,251 ----
+  # check in that version.
+  
+  EXTRA=\
+! 	mkfs.c ulib.c user.h cat.c getsize.c echo.c forktest.c grep.c kill.c\
+! 	ln.c ls.c mkdir.c rm.c stressfs.c testschd.c usertests.c wc.c zombie.c\
+  	printf.c umalloc.c\
+  	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
+  	.gdbinit.tmpl gdbutil\
+diff -crB /home/rganvir/github/xv6-public/memide.c /home/rganvir/github/halfForce/lab5/xv6-public/memide.c
+*** /home/rganvir/github/xv6-public/memide.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/memide.c	2016-09-25 15:51:45.651817076 +0530
+***************
+*** 31,37 ****
+    // no-op
+  }
+  
+! // Sync buf with disk.
+  // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+  // Else if B_VALID is not set, read buf from disk, set B_VALID.
+  void
+--- 31,37 ----
+    // no-op
+  }
+  
+! // Sync buf with disk. 
+  // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
+  // Else if B_VALID is not set, read buf from disk, set B_VALID.
+  void
+***************
+*** 39,46 ****
+  {
+    uchar *p;
+  
+!   if(!holdingsleep(&b->lock))
+!     panic("iderw: buf not locked");
+    if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+      panic("iderw: nothing to do");
+    if(b->dev != 1)
+--- 39,46 ----
+  {
+    uchar *p;
+  
+!   if(!(b->flags & B_BUSY))
+!     panic("iderw: buf not busy");
+    if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
+      panic("iderw: nothing to do");
+    if(b->dev != 1)
+***************
+*** 49,55 ****
+      panic("iderw: block out of range");
+  
+    p = memdisk + b->blockno*BSIZE;
+! 
+    if(b->flags & B_DIRTY){
+      b->flags &= ~B_DIRTY;
+      memmove(p, b->data, BSIZE);
+--- 49,55 ----
+      panic("iderw: block out of range");
+  
+    p = memdisk + b->blockno*BSIZE;
+!   
+    if(b->flags & B_DIRTY){
+      b->flags &= ~B_DIRTY;
+      memmove(p, b->data, BSIZE);
+diff -crB /home/rganvir/github/xv6-public/memlayout.h /home/rganvir/github/halfForce/lab5/xv6-public/memlayout.h
+*** /home/rganvir/github/xv6-public/memlayout.h	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/memlayout.h	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 8,13 ****
+--- 8,20 ----
+  #define KERNBASE 0x80000000         // First kernel virtual address
+  #define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
+  
++ #ifndef __ASSEMBLER__
++ 
++ static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
++ static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
++ 
++ #endif
++ 
+  #define V2P(a) (((uint) (a)) - KERNBASE)
+  #define P2V(a) (((void *) (a)) + KERNBASE)
+  
+diff -crB /home/rganvir/github/xv6-public/mkfs.c /home/rganvir/github/halfForce/lab5/xv6-public/mkfs.c
+*** /home/rganvir/github/xv6-public/mkfs.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/mkfs.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 22,28 ****
+  
+  int nbitmap = FSSIZE/(BSIZE*8) + 1;
+  int ninodeblocks = NINODES / IPB + 1;
+! int nlog = LOGSIZE;
+  int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
+  int nblocks;  // Number of data blocks
+  
+--- 22,28 ----
+  
+  int nbitmap = FSSIZE/(BSIZE*8) + 1;
+  int ninodeblocks = NINODES / IPB + 1;
+! int nlog = LOGSIZE;  
+  int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
+  int nblocks;  // Number of data blocks
+  
+***************
+*** 134,140 ****
+        perror(argv[i]);
+        exit(1);
+      }
+! 
+      // Skip leading _ in name when writing to file system.
+      // The binaries are named _rm, _cat, etc. to keep the
+      // build operating system from trying to execute them
+--- 134,140 ----
+        perror(argv[i]);
+        exit(1);
+      }
+!     
+      // Skip leading _ in name when writing to file system.
+      // The binaries are named _rm, _cat, etc. to keep the
+      // build operating system from trying to execute them
+diff -crB /home/rganvir/github/xv6-public/mmu.h /home/rganvir/github/halfForce/lab5/xv6-public/mmu.h
+*** /home/rganvir/github/xv6-public/mmu.h	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/mmu.h	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 1,4 ****
+! // This file contains definitions for the
+  // x86 memory management unit (MMU).
+  
+  // Eflags register
+--- 1,4 ----
+! // This file contains definitions for the 
+  // x86 memory management unit (MMU).
+  
+  // Eflags register
+***************
+*** 39,45 ****
+  
+  #define CR4_PSE         0x00000010      // Page size extension
+  
+- // various segment selectors.
+  #define SEG_KCODE 1  // kernel code
+  #define SEG_KDATA 2  // kernel data+stack
+  #define SEG_KCPU  3  // kernel per-cpu data
+--- 39,44 ----
+***************
+*** 47,55 ****
+  #define SEG_UDATA 5  // user data+stack
+  #define SEG_TSS   6  // this process's task state
+  
+- // cpu->gdt[NSEGS] holds the above segments.
+- #define NSEGS     7
+- 
+  //PAGEBREAK!
+  #ifndef __ASSEMBLER__
+  // Segment Descriptor
+--- 46,51 ----
+***************
+*** 110,116 ****
+  // | Page Directory |   Page Table   | Offset within Page  |
+  // |      Index     |      Index     |                     |
+  // +----------------+----------------+---------------------+
+! //  \--- PDX(va) --/ \--- PTX(va) --/
+  
+  // page directory index
+  #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
+--- 106,112 ----
+  // | Page Directory |   Page Table   | Offset within Page  |
+  // |      Index     |      Index     |                     |
+  // +----------------+----------------+---------------------+
+! //  \--- PDX(va) --/ \--- PTX(va) --/ 
+  
+  // page directory index
+  #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
+diff -crB /home/rganvir/github/xv6-public/mp.c /home/rganvir/github/halfForce/lab5/xv6-public/mp.c
+*** /home/rganvir/github/xv6-public/mp.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/mp.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 12,26 ****
+  #include "proc.h"
+  
+  struct cpu cpus[NCPU];
+  int ismp;
+  int ncpu;
+  uchar ioapicid;
+  
+  static uchar
+  sum(uchar *addr, int len)
+  {
+    int i, sum;
+! 
+    sum = 0;
+    for(i=0; i<len; i++)
+      sum += addr[i];
+--- 12,33 ----
+  #include "proc.h"
+  
+  struct cpu cpus[NCPU];
++ static struct cpu *bcpu;
+  int ismp;
+  int ncpu;
+  uchar ioapicid;
+  
++ int
++ mpbcpu(void)
++ {
++   return bcpu-cpus;
++ }
++ 
+  static uchar
+  sum(uchar *addr, int len)
+  {
+    int i, sum;
+!   
+    sum = 0;
+    for(i=0; i<len; i++)
+      sum += addr[i];
+***************
+*** 33,39 ****
+  {
+    uchar *e, *p, *addr;
+  
+!   addr = P2V(a);
+    e = addr+len;
+    for(p = addr; p < e; p += sizeof(struct mp))
+      if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+--- 40,46 ----
+  {
+    uchar *e, *p, *addr;
+  
+!   addr = p2v(a);
+    e = addr+len;
+    for(p = addr; p < e; p += sizeof(struct mp))
+      if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
+***************
+*** 78,84 ****
+  
+    if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+      return 0;
+!   conf = (struct mpconf*) P2V((uint) mp->physaddr);
+    if(memcmp(conf, "PCMP", 4) != 0)
+      return 0;
+    if(conf->version != 1 && conf->version != 4)
+--- 85,91 ----
+  
+    if((mp = mpsearch()) == 0 || mp->physaddr == 0)
+      return 0;
+!   conf = (struct mpconf*) p2v((uint) mp->physaddr);
+    if(memcmp(conf, "PCMP", 4) != 0)
+      return 0;
+    if(conf->version != 1 && conf->version != 4)
+***************
+*** 98,103 ****
+--- 105,111 ----
+    struct mpproc *proc;
+    struct mpioapic *ioapic;
+  
++   bcpu = &cpus[0];
+    if((conf = mpconfig(&mp)) == 0)
+      return;
+    ismp = 1;
+***************
+*** 106,115 ****
+      switch(*p){
+      case MPPROC:
+        proc = (struct mpproc*)p;
+!       if(ncpu < NCPU) {
+!         cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
+!         ncpu++;
+        }
+        p += sizeof(struct mpproc);
+        continue;
+      case MPIOAPIC:
+--- 114,127 ----
+      switch(*p){
+      case MPPROC:
+        proc = (struct mpproc*)p;
+!       if(ncpu != proc->apicid){
+!         cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
+!         ismp = 0;
+        }
++       if(proc->flags & MPBOOT)
++         bcpu = &cpus[ncpu];
++       cpus[ncpu].id = ncpu;
++       ncpu++;
+        p += sizeof(struct mpproc);
+        continue;
+      case MPIOAPIC:
+***************
+*** 123,130 ****
+        p += 8;
+        continue;
+      default:
+        ismp = 0;
+-       break;
+      }
+    }
+    if(!ismp){
+--- 135,142 ----
+        p += 8;
+        continue;
+      default:
++       cprintf("mpinit: unknown config type %x\n", *p);
+        ismp = 0;
+      }
+    }
+    if(!ismp){
+diff -crB /home/rganvir/github/xv6-public/picirq.c /home/rganvir/github/halfForce/lab5/xv6-public/picirq.c
+*** /home/rganvir/github/xv6-public/picirq.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/picirq.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 82,87 ****
+    if(irqmask != 0xFFFF)
+      picsetmask(irqmask);
+  }
+- 
+- //PAGEBREAK!
+- // Blank page.
+--- 82,84 ----
+diff -crB /home/rganvir/github/xv6-public/pipe.c /home/rganvir/github/halfForce/lab5/xv6-public/pipe.c
+*** /home/rganvir/github/xv6-public/pipe.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/pipe.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 4,12 ****
+  #include "mmu.h"
+  #include "proc.h"
+  #include "fs.h"
+- #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "file.h"
+  
+  #define PIPESIZE 512
+  
+--- 4,11 ----
+  #include "mmu.h"
+  #include "proc.h"
+  #include "fs.h"
+  #include "file.h"
++ #include "spinlock.h"
+  
+  #define PIPESIZE 512
+  
+diff -crB /home/rganvir/github/xv6-public/proc.c /home/rganvir/github/halfForce/lab5/xv6-public/proc.c
+*** /home/rganvir/github/xv6-public/proc.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/proc.c	2016-09-25 21:06:16.323301992 +0530
+***************
+*** 38,48 ****
+    char *sp;
+  
+    acquire(&ptable.lock);
+! 
+!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+!     if(p->state == UNUSED)
+        goto found;
+- 
+    release(&ptable.lock);
+    return 0;
+  
+--- 38,46 ----
+    char *sp;
+  
+    acquire(&ptable.lock);
+!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+!     if (p->state == UNUSED)
+        goto found;
+    release(&ptable.lock);
+    return 0;
+  
+***************
+*** 53,66 ****
+    release(&ptable.lock);
+  
+    // Allocate kernel stack.
+!   if((p->kstack = kalloc()) == 0){
+      p->state = UNUSED;
+      return 0;
+    }
+    sp = p->kstack + KSTACKSIZE;
+  
+    // Leave room for trap frame.
+!   sp -= sizeof *p->tf;
+    p->tf = (struct trapframe*)sp;
+  
+    // Set up new context to start executing at forkret,
+--- 50,63 ----
+    release(&ptable.lock);
+  
+    // Allocate kernel stack.
+!   if ((p->kstack = kalloc()) == 0) {
+      p->state = UNUSED;
+      return 0;
+    }
+    sp = p->kstack + KSTACKSIZE;
+  
+    // Leave room for trap frame.
+!   sp -= sizeof * p->tf;
+    p->tf = (struct trapframe*)sp;
+  
+    // Set up new context to start executing at forkret,
+***************
+*** 68,76 ****
+    sp -= 4;
+    *(uint*)sp = (uint)trapret;
+  
+!   sp -= sizeof *p->context;
+    p->context = (struct context*)sp;
+!   memset(p->context, 0, sizeof *p->context);
+    p->context->eip = (uint)forkret;
+  
+    return p;
+--- 65,73 ----
+    sp -= 4;
+    *(uint*)sp = (uint)trapret;
+  
+!   sp -= sizeof * p->context;
+    p->context = (struct context*)sp;
+!   memset(p->context, 0, sizeof * p->context);
+    p->context->eip = (uint)forkret;
+  
+    return p;
+***************
+*** 85,93 ****
+    extern char _binary_initcode_start[], _binary_initcode_size[];
+  
+    p = allocproc();
+-   
+    initproc = p;
+!   if((p->pgdir = setupkvm()) == 0)
+      panic("userinit: out of memory?");
+    inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+    p->sz = PGSIZE;
+--- 82,89 ----
+    extern char _binary_initcode_start[], _binary_initcode_size[];
+  
+    p = allocproc();
+    initproc = p;
+!   if ((p->pgdir = setupkvm()) == 0)
+      panic("userinit: out of memory?");
+    inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+    p->sz = PGSIZE;
+***************
+*** 103,117 ****
+    safestrcpy(p->name, "initcode", sizeof(p->name));
+    p->cwd = namei("/");
+  
+-   // this assignment to p->state lets other cores
+-   // run this process. the acquire forces the above
+-   // writes to be visible, and the lock is also needed
+-   // because the assignment might not be atomic.
+-   acquire(&ptable.lock);
+- 
+    p->state = RUNNABLE;
+  
+!   release(&ptable.lock);
+  }
+  
+  // Grow current process's memory by n bytes.
+--- 99,108 ----
+    safestrcpy(p->name, "initcode", sizeof(p->name));
+    p->cwd = namei("/");
+  
+    p->state = RUNNABLE;
+  
+!   p->priority = 1 ;
+! 
+  }
+  
+  // Grow current process's memory by n bytes.
+***************
+*** 122,132 ****
+    uint sz;
+  
+    sz = proc->sz;
+!   if(n > 0){
+!     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+        return -1;
+!   } else if(n < 0){
+!     if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+        return -1;
+    }
+    proc->sz = sz;
+--- 113,123 ----
+    uint sz;
+  
+    sz = proc->sz;
+!   if (n > 0) {
+!     if ((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+        return -1;
+!   } else if (n < 0) {
+!     if ((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+        return -1;
+    }
+    proc->sz = sz;
+***************
+*** 144,155 ****
+    struct proc *np;
+  
+    // Allocate process.
+!   if((np = allocproc()) == 0){
+      return -1;
+-   }
+  
+    // Copy process state from p.
+!   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+      kfree(np->kstack);
+      np->kstack = 0;
+      np->state = UNUSED;
+--- 135,145 ----
+    struct proc *np;
+  
+    // Allocate process.
+!   if ((np = allocproc()) == 0)
+      return -1;
+  
+    // Copy process state from p.
+!   if ((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0) {
+      kfree(np->kstack);
+      np->kstack = 0;
+      np->state = UNUSED;
+***************
+*** 159,169 ****
+    np->parent = proc;
+    *np->tf = *proc->tf;
+  
+    // Clear %eax so that fork returns 0 in the child.
+    np->tf->eax = 0;
+  
+!   for(i = 0; i < NOFILE; i++)
+!     if(proc->ofile[i])
+        np->ofile[i] = filedup(proc->ofile[i]);
+    np->cwd = idup(proc->cwd);
+  
+--- 149,162 ----
+    np->parent = proc;
+    *np->tf = *proc->tf;
+  
++   //change priority here
++   np->priority = proc->priority;
++ 
+    // Clear %eax so that fork returns 0 in the child.
+    np->tf->eax = 0;
+  
+!   for (i = 0; i < NOFILE; i++)
+!     if (proc->ofile[i])
+        np->ofile[i] = filedup(proc->ofile[i]);
+    np->cwd = idup(proc->cwd);
+  
+***************
+*** 171,180 ****
+  
+    pid = np->pid;
+  
+    acquire(&ptable.lock);
+- 
+    np->state = RUNNABLE;
+- 
+    release(&ptable.lock);
+  
+    return pid;
+--- 164,172 ----
+  
+    pid = np->pid;
+  
++   // lock to force the compiler to emit the np->state write last.
+    acquire(&ptable.lock);
+    np->state = RUNNABLE;
+    release(&ptable.lock);
+  
+    return pid;
+***************
+*** 189,200 ****
+    struct proc *p;
+    int fd;
+  
+!   if(proc == initproc)
+      panic("init exiting");
+  
+    // Close all open files.
+!   for(fd = 0; fd < NOFILE; fd++){
+!     if(proc->ofile[fd]){
+        fileclose(proc->ofile[fd]);
+        proc->ofile[fd] = 0;
+      }
+--- 181,192 ----
+    struct proc *p;
+    int fd;
+  
+!   if (proc == initproc)
+      panic("init exiting");
+  
+    // Close all open files.
+!   for (fd = 0; fd < NOFILE; fd++) {
+!     if (proc->ofile[fd]) {
+        fileclose(proc->ofile[fd]);
+        proc->ofile[fd] = 0;
+      }
+***************
+*** 211,220 ****
+    wakeup1(proc->parent);
+  
+    // Pass abandoned children to init.
+!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+!     if(p->parent == proc){
+        p->parent = initproc;
+!       if(p->state == ZOMBIE)
+          wakeup1(initproc);
+      }
+    }
+--- 203,212 ----
+    wakeup1(proc->parent);
+  
+    // Pass abandoned children to init.
+!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+!     if (p->parent == proc) {
+        p->parent = initproc;
+!       if (p->state == ZOMBIE)
+          wakeup1(initproc);
+      }
+    }
+***************
+*** 234,264 ****
+    int havekids, pid;
+  
+    acquire(&ptable.lock);
+!   for(;;){
+!     // Scan through table looking for exited children.
+      havekids = 0;
+!     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+!       if(p->parent != proc)
+          continue;
+        havekids = 1;
+!       if(p->state == ZOMBIE){
+          // Found one.
+          pid = p->pid;
+          kfree(p->kstack);
+          p->kstack = 0;
+          freevm(p->pgdir);
+          p->pid = 0;
+          p->parent = 0;
+          p->name[0] = 0;
+          p->killed = 0;
+-         p->state = UNUSED;
+          release(&ptable.lock);
+          return pid;
+        }
+      }
+  
+      // No point waiting if we don't have any children.
+!     if(!havekids || proc->killed){
+        release(&ptable.lock);
+        return -1;
+      }
+--- 226,256 ----
+    int havekids, pid;
+  
+    acquire(&ptable.lock);
+!   for (;;) {
+!     // Scan through table looking for zombie children.
+      havekids = 0;
+!     for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+!       if (p->parent != proc)
+          continue;
+        havekids = 1;
+!       if (p->state == ZOMBIE) {
+          // Found one.
+          pid = p->pid;
+          kfree(p->kstack);
+          p->kstack = 0;
+          freevm(p->pgdir);
++         p->state = UNUSED;
+          p->pid = 0;
+          p->parent = 0;
+          p->name[0] = 0;
+          p->killed = 0;
+          release(&ptable.lock);
+          return pid;
+        }
+      }
+  
+      // No point waiting if we don't have any children.
+!     if (!havekids || proc->killed) {
+        release(&ptable.lock);
+        return -1;
+      }
+***************
+*** 272,333 ****
+  // Per-CPU process scheduler.
+  // Each CPU calls scheduler() after setting itself up.
+  // Scheduler never returns.  It loops, doing:
+! //  - choose a process to run
+  //  - swtch to start running that process
+  //  - eventually that process transfers control
+  //      via swtch back to the scheduler.
+  void
+  scheduler(void)
+  {
+!   struct proc *p;
+  
+!   for(;;){
+      // Enable interrupts on this processor.
+      sti();
+  
+!     // Loop over process table looking for process to run.
+      acquire(&ptable.lock);
+!     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+!       if(p->state != RUNNABLE)
+          continue;
+! 
+!       // Switch to chosen process.  It is the process's job
+!       // to release ptable.lock and then reacquire it
+!       // before jumping back to us.
+!       proc = p;
+!       switchuvm(p);
+!       p->state = RUNNING;
+!       swtch(&cpu->scheduler, p->context);
+!       switchkvm();
+! 
+!       // Process is done running for now.
+!       // It should have changed its p->state before coming back.
+!       proc = 0;
+      }
+      release(&ptable.lock);
+  
+    }
+  }
+  
+  // Enter scheduler.  Must hold only ptable.lock
+! // and have changed proc->state. Saves and restores
+! // intena because intena is a property of this
+! // kernel thread, not this CPU. It should
+! // be proc->intena and proc->ncli, but that would
+! // break in the few places where a lock is held but
+! // there's no process.
+  void
+  sched(void)
+  {
+    int intena;
+  
+!   if(!holding(&ptable.lock))
+      panic("sched ptable.lock");
+!   if(cpu->ncli != 1)
+      panic("sched locks");
+!   if(proc->state == RUNNING)
+      panic("sched running");
+!   if(readeflags()&FL_IF)
+      panic("sched interruptible");
+    intena = cpu->intena;
+    swtch(&proc->context, cpu->scheduler);
+--- 264,335 ----
+  // Per-CPU process scheduler.
+  // Each CPU calls scheduler() after setting itself up.
+  // Scheduler never returns.  It loops, doing:
+! //  - choose process with maximum priority among RUNNABLE processes
+  //  - swtch to start running that process
+  //  - eventually that process transfers control
+  //      via swtch back to the scheduler.
+  void
+  scheduler(void)
+  {
+!   struct proc *p, *f;
+  
+!   for (;;) {
+      // Enable interrupts on this processor.
+      sti();
+  
+!     int maxp = 0, first = 1;
+!     // Loop over process table looking for pfirstrocess to run.
+      acquire(&ptable.lock);
+!     for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+!       if (p->state != RUNNABLE)
+          continue;
+!       else {
+!         if (first) {
+!           f = p;
+!           maxp = p->priority;
+!           first = 0;
+!           continue;
+!         }
+!         if (p->priority > maxp ) {
+!           f = p;
+!           maxp = p->priority;
+!         }
+!       }
+      }
++ 
++     //cprintf("Scheduler here !\n New proc pid %d priority %d.", f->pid, f->priority );
++     // Switch to chosen process.  It is the process's job
++     // to release ptable.lock and then reacquire it
++     // before jumping back to us.
++ 
++     proc = f;
++     switchuvm(f);
++     f->state = RUNNING;
++     swtch(&cpu->scheduler, proc->context);
++     switchkvm();
++ 
++     // Process is done running for now.
++     // It should have changed its p->state before coming back.
++     proc = 0;
+      release(&ptable.lock);
+  
+    }
+  }
+  
+  // Enter scheduler.  Must hold only ptable.lock
+! // and have changed proc->state.
+  void
+  sched(void)
+  {
+    int intena;
+  
+!   if (!holding(&ptable.lock))
+      panic("sched ptable.lock");
+!   if (cpu->ncli != 1)
+      panic("sched locks");
+!   if (proc->state == RUNNING)
+      panic("sched running");
+!   if (readeflags()&FL_IF)
+      panic("sched interruptible");
+    intena = cpu->intena;
+    swtch(&proc->context, cpu->scheduler);
+***************
+*** 370,379 ****
+  void
+  sleep(void *chan, struct spinlock *lk)
+  {
+!   if(proc == 0)
+      panic("sleep");
+  
+!   if(lk == 0)
+      panic("sleep without lk");
+  
+    // Must acquire ptable.lock in order to
+--- 372,381 ----
+  void
+  sleep(void *chan, struct spinlock *lk)
+  {
+!   if (proc == 0)
+      panic("sleep");
+  
+!   if (lk == 0)
+      panic("sleep without lk");
+  
+    // Must acquire ptable.lock in order to
+***************
+*** 382,388 ****
+    // guaranteed that we won't miss any wakeup
+    // (wakeup runs with ptable.lock locked),
+    // so it's okay to release lk.
+!   if(lk != &ptable.lock){  //DOC: sleeplock0
+      acquire(&ptable.lock);  //DOC: sleeplock1
+      release(lk);
+    }
+--- 384,390 ----
+    // guaranteed that we won't miss any wakeup
+    // (wakeup runs with ptable.lock locked),
+    // so it's okay to release lk.
+!   if (lk != &ptable.lock) { //DOC: sleeplock0
+      acquire(&ptable.lock);  //DOC: sleeplock1
+      release(lk);
+    }
+***************
+*** 396,402 ****
+    proc->chan = 0;
+  
+    // Reacquire original lock.
+!   if(lk != &ptable.lock){  //DOC: sleeplock2
+      release(&ptable.lock);
+      acquire(lk);
+    }
+--- 398,404 ----
+    proc->chan = 0;
+  
+    // Reacquire original lock.
+!   if (lk != &ptable.lock) { //DOC: sleeplock2
+      release(&ptable.lock);
+      acquire(lk);
+    }
+***************
+*** 410,417 ****
+  {
+    struct proc *p;
+  
+!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+!     if(p->state == SLEEPING && p->chan == chan)
+        p->state = RUNNABLE;
+  }
+  
+--- 412,419 ----
+  {
+    struct proc *p;
+  
+!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+!     if (p->state == SLEEPING && p->chan == chan)
+        p->state = RUNNABLE;
+  }
+  
+***************
+*** 433,443 ****
+    struct proc *p;
+  
+    acquire(&ptable.lock);
+!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+!     if(p->pid == pid){
+        p->killed = 1;
+        // Wake process from sleep if necessary.
+!       if(p->state == SLEEPING)
+          p->state = RUNNABLE;
+        release(&ptable.lock);
+        return 0;
+--- 435,445 ----
+    struct proc *p;
+  
+    acquire(&ptable.lock);
+!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+!     if (p->pid == pid) {
+        p->killed = 1;
+        // Wake process from sleep if necessary.
+!       if (p->state == SLEEPING)
+          p->state = RUNNABLE;
+        release(&ptable.lock);
+        return 0;
+***************
+*** 455,485 ****
+  procdump(void)
+  {
+    static char *states[] = {
+!   [UNUSED]    "unused",
+!   [EMBRYO]    "embryo",
+!   [SLEEPING]  "sleep ",
+!   [RUNNABLE]  "runble",
+!   [RUNNING]   "run   ",
+!   [ZOMBIE]    "zombie"
+    };
+    int i;
+    struct proc *p;
+    char *state;
+    uint pc[10];
+  
+!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+!     if(p->state == UNUSED)
+        continue;
+!     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+        state = states[p->state];
+      else
+        state = "???";
+      cprintf("%d %s %s", p->pid, state, p->name);
+!     if(p->state == SLEEPING){
+!       getcallerpcs((uint*)p->context->ebp+2, pc);
+!       for(i=0; i<10 && pc[i] != 0; i++)
+          cprintf(" %p", pc[i]);
+      }
+      cprintf("\n");
+    }
+  }
+--- 457,497 ----
+  procdump(void)
+  {
+    static char *states[] = {
+!     [UNUSED]    "unused",
+!     [EMBRYO]    "embryo",
+!     [SLEEPING]  "sleep ",
+!     [RUNNABLE]  "runble",
+!     [RUNNING]   "run   ",
+!     [ZOMBIE]    "zombie"
+    };
+    int i;
+    struct proc *p;
+    char *state;
+    uint pc[10];
+  
+!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+!     if (p->state == UNUSED)
+        continue;
+!     if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
+        state = states[p->state];
+      else
+        state = "???";
+      cprintf("%d %s %s", p->pid, state, p->name);
+!     if (p->state == SLEEPING) {
+!       getcallerpcs((uint*)p->context->ebp + 2, pc);
+!       for (i = 0; i < 10 && pc[i] != 0; i++)
+          cprintf(" %p", pc[i]);
+      }
+      cprintf("\n");
+    }
+  }
++ 
++ int
++ setprio(int prio){
++ 
++   acquire(&ptable.lock);
++   proc->priority = prio;
++   release(&ptable.lock);
++   
++   return 0;
++ }
+diff -crB /home/rganvir/github/xv6-public/proc.h /home/rganvir/github/halfForce/lab5/xv6-public/proc.h
+*** /home/rganvir/github/xv6-public/proc.h	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/proc.h	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 1,13 ****
+  // Per-CPU state
+  struct cpu {
+!   uchar apicid;                // Local APIC ID
+    struct context *scheduler;   // swtch() here to enter scheduler
+    struct taskstate ts;         // Used by x86 to find stack for interrupt
+    struct segdesc gdt[NSEGS];   // x86 global descriptor table
+    volatile uint started;       // Has the CPU started?
+    int ncli;                    // Depth of pushcli nesting.
+    int intena;                  // Were interrupts enabled before pushcli?
+! 
+    // Cpu-local storage variables; see below
+    struct cpu *cpu;
+    struct proc *proc;           // The currently-running process.
+--- 1,16 ----
++ // Segments in proc->gdt.
++ #define NSEGS     7
++ 
+  // Per-CPU state
+  struct cpu {
+!   uchar id;                    // Local APIC ID; index into cpus[] below
+    struct context *scheduler;   // swtch() here to enter scheduler
+    struct taskstate ts;         // Used by x86 to find stack for interrupt
+    struct segdesc gdt[NSEGS];   // x86 global descriptor table
+    volatile uint started;       // Has the CPU started?
+    int ncli;                    // Depth of pushcli nesting.
+    int intena;                  // Were interrupts enabled before pushcli?
+!   
+    // Cpu-local storage variables; see below
+    struct cpu *cpu;
+    struct proc *proc;           // The currently-running process.
+***************
+*** 63,68 ****
+--- 66,72 ----
+    struct file *ofile[NOFILE];  // Open files
+    struct inode *cwd;           // Current directory
+    char name[16];               // Process name (debugging)
++   int priority;                // priority of process  
+  };
+  
+  // Process memory is laid out contiguously, low addresses first:
+diff -crB /home/rganvir/github/xv6-public/README /home/rganvir/github/halfForce/lab5/xv6-public/README
+*** /home/rganvir/github/xv6-public/README	2016-09-25 20:29:46.347361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/README	2016-09-25 15:51:45.647817076 +0530
+***************
+*** 6,12 ****
+  
+  xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
+  to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
+! 2000)). See also http://pdos.csail.mit.edu/6.828/2016/xv6.html, which
+  provides pointers to on-line resources for v6.
+  
+  xv6 borrows code from the following sources:
+--- 6,12 ----
+  
+  xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
+  to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
+! 2000)). See also http://pdos.csail.mit.edu/6.828/2014/xv6.html, which
+  provides pointers to on-line resources for v6.
+  
+  xv6 borrows code from the following sources:
+***************
+*** 15,50 ****
+      FreeBSD (ioapic.c)
+      NetBSD (console.c)
+  
+! The following people have made contributions: Russ Cox (context switching,
+! locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
+! Clements.
+! 
+! We are also grateful for the bug reports and patches contributed by Silas
+! Boyd-Wickizer, Mike CAT, Nelson Elhage, Nathaniel Filardo, Peter Froehlich,
+! Yakir Goaran, Shivam Handa, Bryan Henry, Jim Huang, Anders Kaseorg, kehao95,
+! Eddie Kohler, Imbar Marinescu, Yandong Mao, Hitoshi Mitake, Carmi Merimovich,
+! Joel Nider, Greg Price, Ayan Shafqat, Eldar Sehayek, Yongming Shen, Cam Tenny,
+! Rafael Ubal, Warren Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi
+! Watanabe, Nicolas Wolovick, Jindong Zhang, and Zou Chang Wei.
+  
+  The code in the files that constitute xv6 is
+! Copyright 2006-2016 Frans Kaashoek, Robert Morris, and Russ Cox.
+  
+  ERROR REPORTS
+  
+! If you spot errors or have suggestions for improvement, please send email to
+! Frans Kaashoek and Robert Morris (kaashoek,rtm@csail.mit.edu).  If you have
+! suggestions for improvements, please keep in mind that the main purpose of xv6
+! is as a teaching operating system for MIT's 6.828. For example, we are in
+! particular interested in simplifications and clarifications, instead of
+! suggestions for new systems calls, more portability, etc.
+  
+  BUILDING AND RUNNING XV6
+  
+  To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run "make".
+  On non-x86 or non-ELF machines (like OS X, even on x86), you will
+  need to install a cross-compiler gcc suite capable of producing x86 ELF
+! binaries.  See http://pdos.csail.mit.edu/6.828/2016/tools.html.
+  Then run "make TOOLPREFIX=i386-jos-elf-".
+  
+  To run xv6, install the QEMU PC simulators.  To run in QEMU, run "make qemu".
+--- 15,46 ----
+      FreeBSD (ioapic.c)
+      NetBSD (console.c)
+  
+! The following people have made contributions:
+!     Russ Cox (context switching, locking)
+!     Cliff Frey (MP)
+!     Xiao Yu (MP)
+!     Nickolai Zeldovich
+!     Austin Clements
+! 
+! In addition, we are grateful for the bug reports and patches contributed by
+! Silas Boyd-Wickizer, Peter Froehlich, Shivam Handa, Anders Kaseorg, Eddie
+! Kohler, Yandong Mao, Hitoshi Mitake, Carmi Merimovich, Joel Nider, Greg Price,
+! Eldar Sehayek, Yongming Shen, Stephen Tu, and Zouchangwei.
+  
+  The code in the files that constitute xv6 is
+! Copyright 2006-2014 Frans Kaashoek, Robert Morris, and Russ Cox.
+  
+  ERROR REPORTS
+  
+! If you spot errors or have suggestions for improvement, please send
+! email to Frans Kaashoek and Robert Morris (kaashoek,rtm@csail.mit.edu). 
+  
+  BUILDING AND RUNNING XV6
+  
+  To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run "make".
+  On non-x86 or non-ELF machines (like OS X, even on x86), you will
+  need to install a cross-compiler gcc suite capable of producing x86 ELF
+! binaries.  See http://pdos.csail.mit.edu/6.828/2014/tools.html.
+  Then run "make TOOLPREFIX=i386-jos-elf-".
+  
+  To run xv6, install the QEMU PC simulators.  To run in QEMU, run "make qemu".
+diff -crB /home/rganvir/github/xv6-public/runoff.list /home/rganvir/github/halfForce/lab5/xv6-public/runoff.list
+*** /home/rganvir/github/xv6-public/runoff.list	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/runoff.list	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 35,48 ****
+  
+  # file system
+  buf.h
+- sleeplock.h
+  fcntl.h
+  stat.h
+  fs.h
+  file.h
+  ide.c
+  bio.c
+- sleeplock.c
+  log.c
+  fs.c
+  file.c
+--- 35,46 ----
+diff -crB /home/rganvir/github/xv6-public/sh.c /home/rganvir/github/halfForce/lab5/xv6-public/sh.c
+*** /home/rganvir/github/xv6-public/sh.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/sh.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 66,72 ****
+  
+    if(cmd == 0)
+      exit();
+! 
+    switch(cmd->type){
+    default:
+      panic("runcmd");
+--- 66,72 ----
+  
+    if(cmd == 0)
+      exit();
+!   
+    switch(cmd->type){
+    default:
+      panic("runcmd");
+***************
+*** 120,126 ****
+      wait();
+      wait();
+      break;
+! 
+    case BACK:
+      bcmd = (struct backcmd*)cmd;
+      if(fork1() == 0)
+--- 120,126 ----
+      wait();
+      wait();
+      break;
+!     
+    case BACK:
+      bcmd = (struct backcmd*)cmd;
+      if(fork1() == 0)
+***************
+*** 146,164 ****
+  {
+    static char buf[100];
+    int fd;
+! 
+!   // Ensure that three file descriptors are open.
+    while((fd = open("console", O_RDWR)) >= 0){
+      if(fd >= 3){
+        close(fd);
+        break;
+      }
+    }
+! 
+    // Read and run input commands.
+    while(getcmd(buf, sizeof(buf)) >= 0){
+      if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+!       // Chdir must be called by the parent, not the child.
+        buf[strlen(buf)-1] = 0;  // chop \n
+        if(chdir(buf+3) < 0)
+          printf(2, "cannot cd %s\n", buf+3);
+--- 146,165 ----
+  {
+    static char buf[100];
+    int fd;
+!   
+!   // Assumes three file descriptors open.
+    while((fd = open("console", O_RDWR)) >= 0){
+      if(fd >= 3){
+        close(fd);
+        break;
+      }
+    }
+!   
+    // Read and run input commands.
+    while(getcmd(buf, sizeof(buf)) >= 0){
+      if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+!       // Clumsy but will have to do for now.
+!       // Chdir has no effect on the parent if run in the child.
+        buf[strlen(buf)-1] = 0;  // chop \n
+        if(chdir(buf+3) < 0)
+          printf(2, "cannot cd %s\n", buf+3);
+***************
+*** 182,188 ****
+  fork1(void)
+  {
+    int pid;
+! 
+    pid = fork();
+    if(pid == -1)
+      panic("fork");
+--- 183,189 ----
+  fork1(void)
+  {
+    int pid;
+!   
+    pid = fork();
+    if(pid == -1)
+      panic("fork");
+***************
+*** 267,273 ****
+  {
+    char *s;
+    int ret;
+! 
+    s = *ps;
+    while(s < es && strchr(whitespace, *s))
+      s++;
+--- 268,274 ----
+  {
+    char *s;
+    int ret;
+!   
+    s = *ps;
+    while(s < es && strchr(whitespace, *s))
+      s++;
+***************
+*** 300,306 ****
+    }
+    if(eq)
+      *eq = s;
+! 
+    while(s < es && strchr(whitespace, *s))
+      s++;
+    *ps = s;
+--- 301,307 ----
+    }
+    if(eq)
+      *eq = s;
+!   
+    while(s < es && strchr(whitespace, *s))
+      s++;
+    *ps = s;
+***************
+*** 311,317 ****
+  peek(char **ps, char *es, char *toks)
+  {
+    char *s;
+! 
+    s = *ps;
+    while(s < es && strchr(whitespace, *s))
+      s++;
+--- 312,318 ----
+  peek(char **ps, char *es, char *toks)
+  {
+    char *s;
+!   
+    s = *ps;
+    while(s < es && strchr(whitespace, *s))
+      s++;
+***************
+*** 419,425 ****
+    int tok, argc;
+    struct execcmd *cmd;
+    struct cmd *ret;
+! 
+    if(peek(ps, es, "("))
+      return parseblock(ps, es);
+  
+--- 420,426 ----
+    int tok, argc;
+    struct execcmd *cmd;
+    struct cmd *ret;
+!   
+    if(peek(ps, es, "("))
+      return parseblock(ps, es);
+  
+***************
+*** 458,464 ****
+  
+    if(cmd == 0)
+      return 0;
+! 
+    switch(cmd->type){
+    case EXEC:
+      ecmd = (struct execcmd*)cmd;
+--- 459,465 ----
+  
+    if(cmd == 0)
+      return 0;
+!   
+    switch(cmd->type){
+    case EXEC:
+      ecmd = (struct execcmd*)cmd;
+***************
+*** 477,483 ****
+      nulterminate(pcmd->left);
+      nulterminate(pcmd->right);
+      break;
+! 
+    case LIST:
+      lcmd = (struct listcmd*)cmd;
+      nulterminate(lcmd->left);
+--- 478,484 ----
+      nulterminate(pcmd->left);
+      nulterminate(pcmd->right);
+      break;
+!     
+    case LIST:
+      lcmd = (struct listcmd*)cmd;
+      nulterminate(lcmd->left);
+Only in /home/rganvir/github/xv6-public/: sleeplock.c
+Only in /home/rganvir/github/xv6-public/: sleeplock.h
+diff -crB /home/rganvir/github/xv6-public/spinlock.c /home/rganvir/github/halfForce/lab5/xv6-public/spinlock.c
+*** /home/rganvir/github/xv6-public/spinlock.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/spinlock.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 29,42 ****
+      panic("acquire");
+  
+    // The xchg is atomic.
+    while(xchg(&lk->locked, 1) != 0)
+      ;
+  
+-   // Tell the C compiler and the processor to not move loads or stores
+-   // past this point, to ensure that the critical section's memory
+-   // references happen after the lock is acquired.
+-   __sync_synchronize();
+- 
+    // Record info about lock acquisition for debugging.
+    lk->cpu = cpu;
+    getcallerpcs(&lk, lk->pcs);
+--- 29,39 ----
+      panic("acquire");
+  
+    // The xchg is atomic.
++   // It also serializes, so that reads after acquire are not
++   // reordered before it. 
+    while(xchg(&lk->locked, 1) != 0)
+      ;
+  
+    // Record info about lock acquisition for debugging.
+    lk->cpu = cpu;
+    getcallerpcs(&lk, lk->pcs);
+***************
+*** 52,68 ****
+    lk->pcs[0] = 0;
+    lk->cpu = 0;
+  
+!   // Tell the C compiler and the processor to not move loads or stores
+!   // past this point, to ensure that all the stores in the critical
+!   // section are visible to other cores before the lock is released.
+!   // Both the C compiler and the hardware may re-order loads and
+!   // stores; __sync_synchronize() tells them both not to.
+!   __sync_synchronize();
+! 
+!   // Release the lock, equivalent to lk->locked = 0.
+!   // This code can't use a C assignment, since it might
+!   // not be atomic. A real OS would use C atomics here.
+!   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+  
+    popcli();
+  }
+--- 49,64 ----
+    lk->pcs[0] = 0;
+    lk->cpu = 0;
+  
+!   // The xchg serializes, so that reads before release are 
+!   // not reordered after it.  The 1996 PentiumPro manual (Volume 3,
+!   // 7.2) says reads can be carried out speculatively and in
+!   // any order, which implies we need to serialize here.
+!   // But the 2007 Intel 64 Architecture Memory Ordering White
+!   // Paper says that Intel 64 and IA-32 will not move a load
+!   // after a store. So lock->locked = 0 would work here.
+!   // The xchg being asm volatile ensures gcc emits it after
+!   // the above assignments (and after the critical section).
+!   xchg(&lk->locked, 0);
+  
+    popcli();
+  }
+***************
+*** 73,79 ****
+  {
+    uint *ebp;
+    int i;
+! 
+    ebp = (uint*)v - 2;
+    for(i = 0; i < 10; i++){
+      if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+--- 69,75 ----
+  {
+    uint *ebp;
+    int i;
+!   
+    ebp = (uint*)v - 2;
+    for(i = 0; i < 10; i++){
+      if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
+***************
+*** 101,112 ****
+  pushcli(void)
+  {
+    int eflags;
+! 
+    eflags = readeflags();
+    cli();
+!   if(cpu->ncli == 0)
+      cpu->intena = eflags & FL_IF;
+-   cpu->ncli += 1;
+  }
+  
+  void
+--- 97,107 ----
+  pushcli(void)
+  {
+    int eflags;
+!   
+    eflags = readeflags();
+    cli();
+!   if(cpu->ncli++ == 0)
+      cpu->intena = eflags & FL_IF;
+  }
+  
+  void
+diff -crB /home/rganvir/github/xv6-public/spinlock.h /home/rganvir/github/halfForce/lab5/xv6-public/spinlock.h
+*** /home/rganvir/github/xv6-public/spinlock.h	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/spinlock.h	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 1,7 ****
+  // Mutual exclusion lock.
+  struct spinlock {
+    uint locked;       // Is the lock held?
+! 
+    // For debugging:
+    char *name;        // Name of lock.
+    struct cpu *cpu;   // The cpu holding the lock.
+--- 1,7 ----
+  // Mutual exclusion lock.
+  struct spinlock {
+    uint locked;       // Is the lock held?
+!   
+    // For debugging:
+    char *name;        // Name of lock.
+    struct cpu *cpu;   // The cpu holding the lock.
+diff -crB /home/rganvir/github/xv6-public/stressfs.c /home/rganvir/github/halfForce/lab5/xv6-public/stressfs.c
+*** /home/rganvir/github/xv6-public/stressfs.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/stressfs.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 44,49 ****
+    close(fd);
+  
+    wait();
+! 
+    exit();
+  }
+--- 44,49 ----
+    close(fd);
+  
+    wait();
+!   
+    exit();
+  }
+diff -crB /home/rganvir/github/xv6-public/string.c /home/rganvir/github/halfForce/lab5/xv6-public/string.c
+*** /home/rganvir/github/xv6-public/string.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/string.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 16,22 ****
+  memcmp(const void *v1, const void *v2, uint n)
+  {
+    const uchar *s1, *s2;
+! 
+    s1 = v1;
+    s2 = v2;
+    while(n-- > 0){
+--- 16,22 ----
+  memcmp(const void *v1, const void *v2, uint n)
+  {
+    const uchar *s1, *s2;
+!   
+    s1 = v1;
+    s2 = v2;
+    while(n-- > 0){
+***************
+*** 69,75 ****
+  strncpy(char *s, const char *t, int n)
+  {
+    char *os;
+! 
+    os = s;
+    while(n-- > 0 && (*s++ = *t++) != 0)
+      ;
+--- 69,75 ----
+  strncpy(char *s, const char *t, int n)
+  {
+    char *os;
+!   
+    os = s;
+    while(n-- > 0 && (*s++ = *t++) != 0)
+      ;
+***************
+*** 83,89 ****
+  safestrcpy(char *s, const char *t, int n)
+  {
+    char *os;
+! 
+    os = s;
+    if(n <= 0)
+      return os;
+--- 83,89 ----
+  safestrcpy(char *s, const char *t, int n)
+  {
+    char *os;
+!   
+    os = s;
+    if(n <= 0)
+      return os;
+diff -crB /home/rganvir/github/xv6-public/syscall.c /home/rganvir/github/halfForce/lab5/xv6-public/syscall.c
+*** /home/rganvir/github/xv6-public/syscall.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/syscall.c	2016-09-25 17:26:04.559662613 +0530
+***************
+*** 49,61 ****
+  }
+  
+  // Fetch the nth word-sized system call argument as a pointer
+! // to a block of memory of size bytes.  Check that the pointer
+  // lies within the process address space.
+  int
+  argptr(int n, char **pp, int size)
+  {
+    int i;
+! 
+    if(argint(n, &i) < 0)
+      return -1;
+    if((uint)i >= proc->sz || (uint)i+size > proc->sz)
+--- 49,61 ----
+  }
+  
+  // Fetch the nth word-sized system call argument as a pointer
+! // to a block of memory of size n bytes.  Check that the pointer
+  // lies within the process address space.
+  int
+  argptr(int n, char **pp, int size)
+  {
+    int i;
+!   
+    if(argint(n, &i) < 0)
+      return -1;
+    if((uint)i >= proc->sz || (uint)i+size > proc->sz)
+***************
+*** 98,103 ****
+--- 98,106 ----
+  extern int sys_wait(void);
+  extern int sys_write(void);
+  extern int sys_uptime(void);
++ extern int sys_getppid(void);
++ extern int sys_setprio(void);
++ extern int sys_getprio(void);
+  
+  static int (*syscalls[])(void) = {
+  [SYS_fork]    sys_fork,
+***************
+*** 121,126 ****
+--- 124,132 ----
+  [SYS_link]    sys_link,
+  [SYS_mkdir]   sys_mkdir,
+  [SYS_close]   sys_close,
++ [SYS_getppid]   sys_getppid,
++ [SYS_setprio]   sys_setprio,
++ [SYS_getprio]   sys_getprio,
+  };
+  
+  void
+diff -crB /home/rganvir/github/xv6-public/syscall.h /home/rganvir/github/halfForce/lab5/xv6-public/syscall.h
+*** /home/rganvir/github/xv6-public/syscall.h	2016-09-21 02:07:36.452385518 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/syscall.h	2016-09-25 17:11:44.435686091 +0530
+***************
+*** 20,22 ****
+--- 20,25 ----
+  #define SYS_link   19
+  #define SYS_mkdir  20
+  #define SYS_close  21
++ #define SYS_getppid  22
++ #define SYS_getprio  23
++ #define SYS_setprio  24
+diff -crB /home/rganvir/github/xv6-public/sysfile.c /home/rganvir/github/halfForce/lab5/xv6-public/sysfile.c
+*** /home/rganvir/github/xv6-public/sysfile.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/sysfile.c	2016-09-25 15:51:45.655817076 +0530
+***************
+*** 11,18 ****
+  #include "mmu.h"
+  #include "proc.h"
+  #include "fs.h"
+- #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "file.h"
+  #include "fcntl.h"
+  
+--- 11,16 ----
+***************
+*** 56,62 ****
+  {
+    struct file *f;
+    int fd;
+! 
+    if(argfd(0, 0, &f) < 0)
+      return -1;
+    if((fd=fdalloc(f)) < 0)
+--- 54,60 ----
+  {
+    struct file *f;
+    int fd;
+!   
+    if(argfd(0, 0, &f) < 0)
+      return -1;
+    if((fd=fdalloc(f)) < 0)
+***************
+*** 94,100 ****
+  {
+    int fd;
+    struct file *f;
+! 
+    if(argfd(0, &fd, &f) < 0)
+      return -1;
+    proc->ofile[fd] = 0;
+--- 92,98 ----
+  {
+    int fd;
+    struct file *f;
+!   
+    if(argfd(0, &fd, &f) < 0)
+      return -1;
+    proc->ofile[fd] = 0;
+***************
+*** 107,113 ****
+  {
+    struct file *f;
+    struct stat *st;
+! 
+    if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+      return -1;
+    return filestat(f, st);
+--- 105,111 ----
+  {
+    struct file *f;
+    struct stat *st;
+!   
+    if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+      return -1;
+    return filestat(f, st);
+***************
+*** 353,362 ****
+  {
+    struct inode *ip;
+    char *path;
+    int major, minor;
+! 
+    begin_op();
+!   if((argstr(0, &path)) < 0 ||
+       argint(1, &major) < 0 ||
+       argint(2, &minor) < 0 ||
+       (ip = create(path, T_DEV, major, minor)) == 0){
+--- 351,361 ----
+  {
+    struct inode *ip;
+    char *path;
++   int len;
+    int major, minor;
+!   
+    begin_op();
+!   if((len=argstr(0, &path)) < 0 ||
+       argint(1, &major) < 0 ||
+       argint(2, &minor) < 0 ||
+       (ip = create(path, T_DEV, major, minor)) == 0){
+diff -crB /home/rganvir/github/xv6-public/sysproc.c /home/rganvir/github/halfForce/lab5/xv6-public/sysproc.c
+*** /home/rganvir/github/xv6-public/sysproc.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/sysproc.c	2016-09-25 17:54:59.463615258 +0530
+***************
+*** 61,67 ****
+  {
+    int n;
+    uint ticks0;
+! 
+    if(argint(0, &n) < 0)
+      return -1;
+    acquire(&tickslock);
+--- 61,67 ----
+  {
+    int n;
+    uint ticks0;
+!   
+    if(argint(0, &n) < 0)
+      return -1;
+    acquire(&tickslock);
+***************
+*** 83,91 ****
+  sys_uptime(void)
+  {
+    uint xticks;
+! 
+    acquire(&tickslock);
+    xticks = ticks;
+    release(&tickslock);
+    return xticks;
+  }
+--- 83,117 ----
+  sys_uptime(void)
+  {
+    uint xticks;
+!   
+    acquire(&tickslock);
+    xticks = ticks;
+    release(&tickslock);
+    return xticks;
+  }
++ 
++ 
++ //get size of current process
++ int
++ sys_getppid(void)
++ {
++   return proc->parent->pid;
++ }
++ 
++ // set priority of prcess as n
++ int
++ sys_setprio(void){
++ 
++   int prio;
++   if(argint(0, &prio) < 0)
++     return -1;
++   return setprio(prio);
++ }
++ 
++ // get priority of process
++ int
++ sys_getprio(void){
++ 
++     return proc->priority;
++ }
++ 
+Only in /home/rganvir/github/halfForce/lab5/xv6-public/: testschd.c
+diff -crB /home/rganvir/github/xv6-public/trap.c /home/rganvir/github/halfForce/lab5/xv6-public/trap.c
+*** /home/rganvir/github/xv6-public/trap.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/trap.c	2016-09-25 15:51:45.659817075 +0530
+***************
+*** 22,28 ****
+    for(i = 0; i < 256; i++)
+      SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+    SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+! 
+    initlock(&tickslock, "time");
+  }
+  
+--- 22,28 ----
+    for(i = 0; i < 256; i++)
+      SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+    SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+!   
+    initlock(&tickslock, "time");
+  }
+  
+***************
+*** 48,54 ****
+  
+    switch(tf->trapno){
+    case T_IRQ0 + IRQ_TIMER:
+!     if(cpunum() == 0){
+        acquire(&tickslock);
+        ticks++;
+        wakeup(&ticks);
+--- 48,54 ----
+  
+    switch(tf->trapno){
+    case T_IRQ0 + IRQ_TIMER:
+!     if(cpu->id == 0){
+        acquire(&tickslock);
+        ticks++;
+        wakeup(&ticks);
+***************
+*** 74,101 ****
+    case T_IRQ0 + 7:
+    case T_IRQ0 + IRQ_SPURIOUS:
+      cprintf("cpu%d: spurious interrupt at %x:%x\n",
+!             cpunum(), tf->cs, tf->eip);
+      lapiceoi();
+      break;
+! 
+    //PAGEBREAK: 13
+    default:
+      if(proc == 0 || (tf->cs&3) == 0){
+        // In kernel, it must be our mistake.
+        cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+!               tf->trapno, cpunum(), tf->eip, rcr2());
+        panic("trap");
+      }
+      // In user space, assume process misbehaved.
+      cprintf("pid %d %s: trap %d err %d on cpu %d "
+              "eip 0x%x addr 0x%x--kill proc\n",
+!             proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
+              rcr2());
+      proc->killed = 1;
+    }
+  
+    // Force process exit if it has been killed and is in user space.
+!   // (If it is still executing in the kernel, let it keep running
+    // until it gets to the regular system call return.)
+    if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+      exit();
+--- 74,101 ----
+    case T_IRQ0 + 7:
+    case T_IRQ0 + IRQ_SPURIOUS:
+      cprintf("cpu%d: spurious interrupt at %x:%x\n",
+!             cpu->id, tf->cs, tf->eip);
+      lapiceoi();
+      break;
+!    
+    //PAGEBREAK: 13
+    default:
+      if(proc == 0 || (tf->cs&3) == 0){
+        // In kernel, it must be our mistake.
+        cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
+!               tf->trapno, cpu->id, tf->eip, rcr2());
+        panic("trap");
+      }
+      // In user space, assume process misbehaved.
+      cprintf("pid %d %s: trap %d err %d on cpu %d "
+              "eip 0x%x addr 0x%x--kill proc\n",
+!             proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
+              rcr2());
+      proc->killed = 1;
+    }
+  
+    // Force process exit if it has been killed and is in user space.
+!   // (If it is still executing in the kernel, let it keep running 
+    // until it gets to the regular system call return.)
+    if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+      exit();
+diff -crB /home/rganvir/github/xv6-public/uart.c /home/rganvir/github/halfForce/lab5/xv6-public/uart.c
+*** /home/rganvir/github/xv6-public/uart.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/uart.c	2016-09-25 15:51:45.659817075 +0530
+***************
+*** 5,11 ****
+  #include "param.h"
+  #include "traps.h"
+  #include "spinlock.h"
+- #include "sleeplock.h"
+  #include "fs.h"
+  #include "file.h"
+  #include "mmu.h"
+--- 5,10 ----
+***************
+*** 23,29 ****
+  
+    // Turn off the FIFO
+    outb(COM1+2, 0);
+! 
+    // 9600 baud, 8 data bits, 1 stop bit, parity off.
+    outb(COM1+3, 0x80);    // Unlock divisor
+    outb(COM1+0, 115200/9600);
+--- 22,28 ----
+  
+    // Turn off the FIFO
+    outb(COM1+2, 0);
+!   
+    // 9600 baud, 8 data bits, 1 stop bit, parity off.
+    outb(COM1+3, 0x80);    // Unlock divisor
+    outb(COM1+0, 115200/9600);
+***************
+*** 43,49 ****
+    inb(COM1+0);
+    picenable(IRQ_COM1);
+    ioapicenable(IRQ_COM1, 0);
+! 
+    // Announce that we're here.
+    for(p="xv6...\n"; *p; p++)
+      uartputc(*p);
+--- 42,48 ----
+    inb(COM1+0);
+    picenable(IRQ_COM1);
+    ioapicenable(IRQ_COM1, 0);
+!   
+    // Announce that we're here.
+    for(p="xv6...\n"; *p; p++)
+      uartputc(*p);
+diff -crB /home/rganvir/github/xv6-public/ulib.c /home/rganvir/github/halfForce/lab5/xv6-public/ulib.c
+*** /home/rganvir/github/xv6-public/ulib.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/ulib.c	2016-09-25 15:51:45.659817075 +0530
+***************
+*** 96,102 ****
+  memmove(void *vdst, void *vsrc, int n)
+  {
+    char *dst, *src;
+! 
+    dst = vdst;
+    src = vsrc;
+    while(n-- > 0)
+--- 96,102 ----
+  memmove(void *vdst, void *vsrc, int n)
+  {
+    char *dst, *src;
+!   
+    dst = vdst;
+    src = vsrc;
+    while(n-- > 0)
+diff -crB /home/rganvir/github/xv6-public/user.h /home/rganvir/github/halfForce/lab5/xv6-public/user.h
+*** /home/rganvir/github/xv6-public/user.h	2016-07-20 14:18:26.117200692 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/user.h	2016-09-25 17:26:20.075662190 +0530
+***************
+*** 23,28 ****
+--- 23,32 ----
+  char* sbrk(int);
+  int sleep(int);
+  int uptime(void);
++ int getppid(void);
++ int setprio(int);
++ int getprio(void);
++ 
+  
+  // ulib.c
+  int stat(char*, struct stat*);
+diff -crB /home/rganvir/github/xv6-public/usertests.c /home/rganvir/github/halfForce/lab5/xv6-public/usertests.c
+*** /home/rganvir/github/xv6-public/usertests.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/usertests.c	2016-09-25 15:51:45.659817075 +0530
+***************
+*** 539,545 ****
+          printf(1, "create failed\n");
+          exit();
+        }
+! 
+        memset(buf, '0'+pi, 512);
+        for(i = 0; i < 12; i++){
+          if((n = write(fd, buf, 500)) != 500){
+--- 539,545 ----
+          printf(1, "create failed\n");
+          exit();
+        }
+!       
+        memset(buf, '0'+pi, 512);
+        for(i = 0; i < 12; i++){
+          if((n = write(fd, buf, 500)) != 500){
+***************
+*** 882,888 ****
+  
+    if(pid)
+      wait();
+!   else
+      exit();
+  
+    printf(1, "linkunlink ok\n");
+--- 882,888 ----
+  
+    if(pid)
+      wait();
+!   else 
+      exit();
+  
+    printf(1, "linkunlink ok\n");
+***************
+*** 951,957 ****
+    }
+    write(fd, "ff", 2);
+    close(fd);
+! 
+    if(unlink("dd") >= 0){
+      printf(1, "unlink dd (non-empty dir) succeeded!\n");
+      exit();
+--- 951,957 ----
+    }
+    write(fd, "ff", 2);
+    close(fd);
+!   
+    if(unlink("dd") >= 0){
+      printf(1, "unlink dd (non-empty dir) succeeded!\n");
+      exit();
+***************
+*** 1390,1413 ****
+      if(pid == 0)
+        exit();
+    }
+! 
+    if(n == 1000){
+      printf(1, "fork claimed to work 1000 times!\n");
+      exit();
+    }
+! 
+    for(; n > 0; n--){
+      if(wait() < 0){
+        printf(1, "wait stopped early\n");
+        exit();
+      }
+    }
+! 
+    if(wait() != -1){
+      printf(1, "wait got too many\n");
+      exit();
+    }
+! 
+    printf(1, "fork test OK\n");
+  }
+  
+--- 1390,1413 ----
+      if(pid == 0)
+        exit();
+    }
+!   
+    if(n == 1000){
+      printf(1, "fork claimed to work 1000 times!\n");
+      exit();
+    }
+!   
+    for(; n > 0; n--){
+      if(wait() < 0){
+        printf(1, "wait stopped early\n");
+        exit();
+      }
+    }
+!   
+    if(wait() != -1){
+      printf(1, "wait got too many\n");
+      exit();
+    }
+!   
+    printf(1, "fork test OK\n");
+  }
+  
+***************
+*** 1424,1430 ****
+    // can one sbrk() less than a page?
+    a = sbrk(0);
+    int i;
+!   for(i = 0; i < 5000; i++){
+      b = sbrk(1);
+      if(b != a){
+        printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+--- 1424,1430 ----
+    // can one sbrk() less than a page?
+    a = sbrk(0);
+    int i;
+!   for(i = 0; i < 5000; i++){ 
+      b = sbrk(1);
+      if(b != a){
+        printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+***************
+*** 1453,1459 ****
+    a = sbrk(0);
+    amt = (BIG) - (uint)a;
+    p = sbrk(amt);
+!   if (p != a) {
+      printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+      exit();
+    }
+--- 1453,1459 ----
+    a = sbrk(0);
+    amt = (BIG) - (uint)a;
+    p = sbrk(amt);
+!   if (p != a) { 
+      printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
+      exit();
+    }
+***************
+*** 1492,1498 ****
+      printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+      exit();
+    }
+! 
+    // can we read the kernel's memory?
+    for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+      ppid = getpid();
+--- 1492,1498 ----
+      printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
+      exit();
+    }
+!   
+    // can we read the kernel's memory?
+    for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+      ppid = getpid();
+***************
+*** 1695,1729 ****
+    printf(1, "fsfull test finished\n");
+  }
+  
+- void
+- uio()
+- {
+-   #define RTC_ADDR 0x70
+-   #define RTC_DATA 0x71
+- 
+-   ushort port = 0;
+-   uchar val = 0;
+-   int pid;
+- 
+-   printf(1, "uio test\n");
+-   pid = fork();
+-   if(pid == 0){
+-     port = RTC_ADDR;
+-     val = 0x09;  /* year */
+-     /* http://wiki.osdev.org/Inline_Assembly/Examples */
+-     asm volatile("outb %0,%1"::"a"(val), "d" (port));
+-     port = RTC_DATA;
+-     asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
+-     printf(1, "uio: uio succeeded; test FAILED\n");
+-     exit();
+-   } else if(pid < 0){
+-     printf (1, "fork failed\n");
+-     exit();
+-   }
+-   wait();
+-   printf(1, "uio test done\n");
+- }
+- 
+  unsigned long randstate = 1;
+  unsigned int
+  rand()
+--- 1695,1700 ----
+***************
+*** 1780,1788 ****
+    iref();
+    forktest();
+    bigdir(); // slow
+- 
+-   uio();
+- 
+    exectest();
+  
+    exit();
+--- 1751,1756 ----
+diff -crB /home/rganvir/github/xv6-public/usys.S /home/rganvir/github/halfForce/lab5/xv6-public/usys.S
+*** /home/rganvir/github/xv6-public/usys.S	2016-07-20 14:18:26.117200692 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/usys.S	2016-09-25 17:15:07.111680558 +0530
+***************
+*** 29,31 ****
+--- 29,35 ----
+  SYSCALL(sbrk)
+  SYSCALL(sleep)
+  SYSCALL(uptime)
++ SYSCALL(getppid)
++ SYSCALL(setprio)
++ SYSCALL(getprio)
++ 
+diff -crB /home/rganvir/github/xv6-public/vm.c /home/rganvir/github/halfForce/lab5/xv6-public/vm.c
+*** /home/rganvir/github/xv6-public/vm.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/vm.c	2016-09-25 15:51:45.659817075 +0530
+***************
+*** 9,14 ****
+--- 9,15 ----
+  
+  extern char data[];  // defined by kernel.ld
+  pde_t *kpgdir;  // for use in scheduler()
++ struct segdesc gdt[NSEGS];
+  
+  // Set up CPU's kernel segment descriptors.
+  // Run once on entry on each CPU.
+***************
+*** 27,38 ****
+    c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+    c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+  
+!   // Map cpu and proc -- these are private per cpu.
+    c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+  
+    lgdt(c->gdt, sizeof(c->gdt));
+    loadgs(SEG_KCPU << 3);
+! 
+    // Initialize cpu-local storage.
+    cpu = c;
+    proc = 0;
+--- 28,39 ----
+    c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
+    c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
+  
+!   // Map cpu, and curproc
+    c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
+  
+    lgdt(c->gdt, sizeof(c->gdt));
+    loadgs(SEG_KCPU << 3);
+!   
+    // Initialize cpu-local storage.
+    cpu = c;
+    proc = 0;
+***************
+*** 49,64 ****
+  
+    pde = &pgdir[PDX(va)];
+    if(*pde & PTE_P){
+!     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+    } else {
+      if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+        return 0;
+      // Make sure all those PTE_P bits are zero.
+      memset(pgtab, 0, PGSIZE);
+      // The permissions here are overly generous, but they can
+!     // be further restricted by the permissions in the page table
+      // entries, if necessary.
+!     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+    }
+    return &pgtab[PTX(va)];
+  }
+--- 50,65 ----
+  
+    pde = &pgdir[PDX(va)];
+    if(*pde & PTE_P){
+!     pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
+    } else {
+      if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+        return 0;
+      // Make sure all those PTE_P bits are zero.
+      memset(pgtab, 0, PGSIZE);
+      // The permissions here are overly generous, but they can
+!     // be further restricted by the permissions in the page table 
+      // entries, if necessary.
+!     *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
+    }
+    return &pgtab[PTX(va)];
+  }
+***************
+*** 71,77 ****
+  {
+    char *a, *last;
+    pte_t *pte;
+! 
+    a = (char*)PGROUNDDOWN((uint)va);
+    last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+    for(;;){
+--- 72,78 ----
+  {
+    char *a, *last;
+    pte_t *pte;
+!   
+    a = (char*)PGROUNDDOWN((uint)va);
+    last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
+    for(;;){
+***************
+*** 93,99 ****
+  // current process's page table during system calls and interrupts;
+  // page protection bits prevent user code from using the kernel's
+  // mappings.
+! //
+  // setupkvm() and exec() set up every page table like this:
+  //
+  //   0..KERNBASE: user memory (text+data+stack+heap), mapped to
+--- 94,100 ----
+  // current process's page table during system calls and interrupts;
+  // page protection bits prevent user code from using the kernel's
+  // mappings.
+! // 
+  // setupkvm() and exec() set up every page table like this:
+  //
+  //   0..KERNBASE: user memory (text+data+stack+heap), mapped to
+***************
+*** 101,107 ****
+  //   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
+  //   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
+  //                for the kernel's instructions and r/o data
+! //   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
+  //                                  rw data + free physical memory
+  //   0xfe000000..0: mapped direct (devices such as ioapic)
+  //
+--- 102,108 ----
+  //   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
+  //   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
+  //                for the kernel's instructions and r/o data
+! //   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP, 
+  //                                  rw data + free physical memory
+  //   0xfe000000..0: mapped direct (devices such as ioapic)
+  //
+***************
+*** 133,142 ****
+    if((pgdir = (pde_t*)kalloc()) == 0)
+      return 0;
+    memset(pgdir, 0, PGSIZE);
+!   if (P2V(PHYSTOP) > (void*)DEVSPACE)
+      panic("PHYSTOP too high");
+    for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+!     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+                  (uint)k->phys_start, k->perm) < 0)
+        return 0;
+    return pgdir;
+--- 134,143 ----
+    if((pgdir = (pde_t*)kalloc()) == 0)
+      return 0;
+    memset(pgdir, 0, PGSIZE);
+!   if (p2v(PHYSTOP) > (void*)DEVSPACE)
+      panic("PHYSTOP too high");
+    for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+!     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
+                  (uint)k->phys_start, k->perm) < 0)
+        return 0;
+    return pgdir;
+***************
+*** 156,162 ****
+  void
+  switchkvm(void)
+  {
+!   lcr3(V2P(kpgdir));   // switch to the kernel page table
+  }
+  
+  // Switch TSS and h/w page table to correspond to process p.
+--- 157,163 ----
+  void
+  switchkvm(void)
+  {
+!   lcr3(v2p(kpgdir));   // switch to the kernel page table
+  }
+  
+  // Switch TSS and h/w page table to correspond to process p.
+***************
+*** 168,180 ****
+    cpu->gdt[SEG_TSS].s = 0;
+    cpu->ts.ss0 = SEG_KDATA << 3;
+    cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
+-   // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
+-   // forbids I/O instructions (e.g., inb and outb) from user space
+-   cpu->ts.iomb = (ushort) 0xFFFF;
+    ltr(SEG_TSS << 3);
+    if(p->pgdir == 0)
+      panic("switchuvm: no pgdir");
+!   lcr3(V2P(p->pgdir));  // switch to process's address space
+    popcli();
+  }
+  
+--- 169,178 ----
+    cpu->gdt[SEG_TSS].s = 0;
+    cpu->ts.ss0 = SEG_KDATA << 3;
+    cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
+    ltr(SEG_TSS << 3);
+    if(p->pgdir == 0)
+      panic("switchuvm: no pgdir");
+!   lcr3(v2p(p->pgdir));  // switch to new address space
+    popcli();
+  }
+  
+***************
+*** 184,195 ****
+  inituvm(pde_t *pgdir, char *init, uint sz)
+  {
+    char *mem;
+! 
+    if(sz >= PGSIZE)
+      panic("inituvm: more than a page");
+    mem = kalloc();
+    memset(mem, 0, PGSIZE);
+!   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+    memmove(mem, init, sz);
+  }
+  
+--- 182,193 ----
+  inituvm(pde_t *pgdir, char *init, uint sz)
+  {
+    char *mem;
+!   
+    if(sz >= PGSIZE)
+      panic("inituvm: more than a page");
+    mem = kalloc();
+    memset(mem, 0, PGSIZE);
+!   mappages(pgdir, 0, PGSIZE, v2p(mem), PTE_W|PTE_U);
+    memmove(mem, init, sz);
+  }
+  
+***************
+*** 211,217 ****
+        n = sz - i;
+      else
+        n = PGSIZE;
+!     if(readi(ip, P2V(pa), offset+i, n) != n)
+        return -1;
+    }
+    return 0;
+--- 209,215 ----
+        n = sz - i;
+      else
+        n = PGSIZE;
+!     if(readi(ip, p2v(pa), offset+i, n) != n)
+        return -1;
+    }
+    return 0;
+***************
+*** 239,250 ****
+        return 0;
+      }
+      memset(mem, 0, PGSIZE);
+!     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+!       cprintf("allocuvm out of memory (2)\n");
+!       deallocuvm(pgdir, newsz, oldsz);
+!       kfree(mem);
+!       return 0;
+!     }
+    }
+    return newsz;
+  }
+--- 237,243 ----
+        return 0;
+      }
+      memset(mem, 0, PGSIZE);
+!     mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
+    }
+    return newsz;
+  }
+***************
+*** 271,277 ****
+        pa = PTE_ADDR(*pte);
+        if(pa == 0)
+          panic("kfree");
+!       char *v = P2V(pa);
+        kfree(v);
+        *pte = 0;
+      }
+--- 264,270 ----
+        pa = PTE_ADDR(*pte);
+        if(pa == 0)
+          panic("kfree");
+!       char *v = p2v(pa);
+        kfree(v);
+        *pte = 0;
+      }
+***************
+*** 291,297 ****
+    deallocuvm(pgdir, KERNBASE, 0);
+    for(i = 0; i < NPDENTRIES; i++){
+      if(pgdir[i] & PTE_P){
+!       char * v = P2V(PTE_ADDR(pgdir[i]));
+        kfree(v);
+      }
+    }
+--- 284,290 ----
+    deallocuvm(pgdir, KERNBASE, 0);
+    for(i = 0; i < NPDENTRIES; i++){
+      if(pgdir[i] & PTE_P){
+!       char * v = p2v(PTE_ADDR(pgdir[i]));
+        kfree(v);
+      }
+    }
+***************
+*** 332,339 ****
+      flags = PTE_FLAGS(*pte);
+      if((mem = kalloc()) == 0)
+        goto bad;
+!     memmove(mem, (char*)P2V(pa), PGSIZE);
+!     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
+        goto bad;
+    }
+    return d;
+--- 325,332 ----
+      flags = PTE_FLAGS(*pte);
+      if((mem = kalloc()) == 0)
+        goto bad;
+!     memmove(mem, (char*)p2v(pa), PGSIZE);
+!     if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
+        goto bad;
+    }
+    return d;
+***************
+*** 355,361 ****
+      return 0;
+    if((*pte & PTE_U) == 0)
+      return 0;
+!   return (char*)P2V(PTE_ADDR(*pte));
+  }
+  
+  // Copy len bytes from p to user address va in page table pgdir.
+--- 348,354 ----
+      return 0;
+    if((*pte & PTE_U) == 0)
+      return 0;
+!   return (char*)p2v(PTE_ADDR(*pte));
+  }
+  
+  // Copy len bytes from p to user address va in page table pgdir.
+diff -crB /home/rganvir/github/xv6-public/x86.h /home/rganvir/github/halfForce/lab5/xv6-public/x86.h
+*** /home/rganvir/github/xv6-public/x86.h	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/x86.h	2016-09-25 15:51:45.659817075 +0530
+***************
+*** 121,127 ****
+  xchg(volatile uint *addr, uint newval)
+  {
+    uint result;
+! 
+    // The + in "+m" denotes a read-modify-write operand.
+    asm volatile("lock; xchgl %0, %1" :
+                 "+m" (*addr), "=a" (result) :
+--- 121,127 ----
+  xchg(volatile uint *addr, uint newval)
+  {
+    uint result;
+!   
+    // The + in "+m" denotes a read-modify-write operand.
+    asm volatile("lock; xchgl %0, %1" :
+                 "+m" (*addr), "=a" (result) :
+***************
+*** 139,145 ****
+  }
+  
+  static inline void
+! lcr3(uint val)
+  {
+    asm volatile("movl %0,%%cr3" : : "r" (val));
+  }
+--- 139,145 ----
+  }
+  
+  static inline void
+! lcr3(uint val) 
+  {
+    asm volatile("movl %0,%%cr3" : : "r" (val));
+  }
+diff -crB /home/rganvir/github/xv6-public/zombie.c /home/rganvir/github/halfForce/lab5/xv6-public/zombie.c
+*** /home/rganvir/github/xv6-public/zombie.c	2016-09-25 20:29:46.351361768 +0530
+--- /home/rganvir/github/halfForce/lab5/xv6-public/zombie.c	2016-09-25 15:51:45.659817075 +0530
+***************
+*** 1,4 ****
+! // Create a zombie process that
+  // must be reparented at exit.
+  
+  #include "types.h"
+--- 1,4 ----
+! // Create a zombie process that 
+  // must be reparented at exit.
+  
+  #include "types.h"
diff -ruN xv6-orig/lapic.c xv6-public/lapic.c
--- xv6-orig/lapic.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/lapic.c	2016-09-25 15:51:45.651817076 +0530
@@ -1,7 +1,6 @@
 // The local APIC manages internal (non-I/O) interrupts.
 // See Chapter 8 & Appendix C of Intel processor manual volume 3.
 
-#include "param.h"
 #include "types.h"
 #include "defs.h"
 #include "date.h"
@@ -9,7 +8,6 @@
 #include "traps.h"
 #include "mmu.h"
 #include "x86.h"
-#include "proc.h"  // ncpu
 
 // Local APIC registers, divided by 4 for use as uint[] indices.
 #define ID      (0x0020/4)   // ID
@@ -55,19 +53,19 @@
 void
 lapicinit(void)
 {
-  if(!lapic)
+  if(!lapic) 
     return;
 
   // Enable local APIC; set spurious interrupt vector.
   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
 
   // The timer repeatedly counts down at bus frequency
-  // from lapic[TICR] and then issues an interrupt.
+  // from lapic[TICR] and then issues an interrupt.  
   // If xv6 cared more about precise timekeeping,
   // TICR would be calibrated using an external time source.
   lapicw(TDCR, X1);
   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
-  lapicw(TICR, 10000000);
+  lapicw(TICR, 10000000); 
 
   // Disable logical interrupt lines.
   lapicw(LINT0, MASKED);
@@ -101,8 +99,6 @@
 int
 cpunum(void)
 {
-  int apicid, i;
-  
   // Cannot call cpu when interrupts are enabled:
   // result not guaranteed to last long enough to be used!
   // Would prefer to panic but even printing is chancy here:
@@ -115,15 +111,9 @@
         __builtin_return_address(0));
   }
 
-  if (!lapic)
-    return 0;
-
-  apicid = lapic[ID] >> 24;
-  for (i = 0; i < ncpu; ++i) {
-    if (cpus[i].apicid == apicid)
-      return i;
-  }
-  panic("unknown apicid\n");
+  if(lapic)
+    return lapic[ID]>>24;
+  return 0;
 }
 
 // Acknowledge interrupt.
@@ -151,7 +141,7 @@
 {
   int i;
   ushort *wrv;
-
+  
   // "The BSP must initialize CMOS shutdown code to 0AH
   // and the warm reset vector (DWORD based at 40:67) to point at
   // the AP startup code prior to the [universal startup algorithm]."
@@ -168,7 +158,7 @@
   microdelay(200);
   lapicw(ICRLO, INIT | LEVEL);
   microdelay(100);    // should be 10ms, but too slow in Bochs!
-
+  
   // Send startup IPI (twice!) to enter code.
   // Regular hardware is supposed to only accept a STARTUP
   // when it is in the halted state due to an INIT.  So the second
@@ -221,17 +211,17 @@
   bcd = (sb & (1 << 2)) == 0;
 
   // make sure CMOS doesn't modify time while we read it
-  for(;;) {
+  for (;;) {
     fill_rtcdate(&t1);
-    if(cmos_read(CMOS_STATA) & CMOS_UIP)
+    if (cmos_read(CMOS_STATA) & CMOS_UIP)
         continue;
     fill_rtcdate(&t2);
-    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
+    if (memcmp(&t1, &t2, sizeof(t1)) == 0)
       break;
   }
 
   // convert
-  if(bcd) {
+  if (bcd) {
 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
     CONV(second);
     CONV(minute);
diff -ruN xv6-orig/LICENSE xv6-public/LICENSE
--- xv6-orig/LICENSE	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/LICENSE	2016-09-25 15:51:45.647817076 +0530
@@ -1,6 +1,6 @@
 The xv6 software is:
 
-Copyright (c) 2006-2016 Frans Kaashoek, Robert Morris, Russ Cox,
+Copyright (c) 2006-2009 Frans Kaashoek, Robert Morris, Russ Cox,
                         Massachusetts Institute of Technology
 
 Permission is hereby granted, free of charge, to any person obtaining
diff -ruN xv6-orig/log.c xv6-public/log.c
--- xv6-orig/log.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/log.c	2016-09-25 15:51:45.651817076 +0530
@@ -2,7 +2,6 @@
 #include "defs.h"
 #include "param.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "buf.h"
 
@@ -32,7 +31,7 @@
 // Contents of the header block, used for both the on-disk header block
 // and to keep track in memory of logged block# before commit.
 struct logheader {
-  int n;
+  int n;   
   int block[LOGSIZE];
 };
 
@@ -66,7 +65,7 @@
 }
 
 // Copy committed blocks from log to their home location
-static void
+static void 
 install_trans(void)
 {
   int tail;
@@ -76,7 +75,7 @@
     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
     memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
     bwrite(dbuf);  // write dst to disk
-    brelse(lbuf);
+    brelse(lbuf); 
     brelse(dbuf);
   }
 }
@@ -115,7 +114,7 @@
 static void
 recover_from_log(void)
 {
-  read_head();
+  read_head();      
   install_trans(); // if committed, copy from log to disk
   log.lh.n = 0;
   write_head(); // clear the log
@@ -172,7 +171,7 @@
 }
 
 // Copy modified blocks from cache to log.
-static void
+static void 
 write_log(void)
 {
   int tail;
@@ -182,7 +181,7 @@
     struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
     memmove(to->data, from->data, BSIZE);
     bwrite(to);  // write the log
-    brelse(from);
+    brelse(from); 
     brelse(to);
   }
 }
@@ -194,7 +193,7 @@
     write_log();     // Write modified blocks from cache to log
     write_head();    // Write header to disk -- the real commit
     install_trans(); // Now install writes to home locations
-    log.lh.n = 0;
+    log.lh.n = 0; 
     write_head();    // Erase the transaction from the log
   }
 }
diff -ruN xv6-orig/ls.c xv6-public/ls.c
--- xv6-orig/ls.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/ls.c	2016-09-25 15:51:45.651817076 +0530
@@ -8,12 +8,12 @@
 {
   static char buf[DIRSIZ+1];
   char *p;
-
+  
   // Find first character after last slash.
   for(p=path+strlen(path); p >= path && *p != '/'; p--)
     ;
   p++;
-
+  
   // Return blank-padded name.
   if(strlen(p) >= DIRSIZ)
     return p;
@@ -29,23 +29,23 @@
   int fd;
   struct dirent de;
   struct stat st;
-
+  
   if((fd = open(path, 0)) < 0){
     printf(2, "ls: cannot open %s\n", path);
     return;
   }
-
+  
   if(fstat(fd, &st) < 0){
     printf(2, "ls: cannot stat %s\n", path);
     close(fd);
     return;
   }
-
+  
   switch(st.type){
   case T_FILE:
     printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
     break;
-
+  
   case T_DIR:
     if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
       printf(1, "ls: path too long\n");
diff -ruN xv6-orig/main.c xv6-public/main.c
--- xv6-orig/main.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/main.c	2016-09-25 15:51:45.651817076 +0530
@@ -19,13 +19,13 @@
 {
   kinit1(end, P2V(4*1024*1024)); // phys page allocator
   kvmalloc();      // kernel page table
-  mpinit();        // detect other processors
-  lapicinit();     // interrupt controller
-  seginit();       // segment descriptors
-  cprintf("\ncpu%d: starting xv6\n\n", cpunum());
-  picinit();       // another interrupt controller
+  mpinit();        // collect info about this machine
+  lapicinit();
+  seginit();       // set up segments
+  cprintf("\ncpu%d: starting xv6\n\n", cpu->id);
+  picinit();       // interrupt controller
   ioapicinit();    // another interrupt controller
-  consoleinit();   // console hardware
+  consoleinit();   // I/O devices & their interrupts
   uartinit();      // serial port
   pinit();         // process table
   tvinit();        // trap vectors
@@ -37,14 +37,15 @@
   startothers();   // start other processors
   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); // must come after startothers()
   userinit();      // first user process
-  mpmain();        // finish this processor's setup
+  // Finish setting up this processor in mpmain.
+  mpmain();
 }
 
 // Other CPUs jump here from entryother.S.
 static void
 mpenter(void)
 {
-  switchkvm();
+  switchkvm(); 
   seginit();
   lapicinit();
   mpmain();
@@ -54,7 +55,7 @@
 static void
 mpmain(void)
 {
-  cprintf("cpu%d: starting\n", cpunum());
+  cprintf("cpu%d: starting\n", cpu->id);
   idtinit();       // load idt register
   xchg(&cpu->started, 1); // tell startothers() we're up
   scheduler();     // start running processes
@@ -74,22 +75,22 @@
   // Write entry code to unused memory at 0x7000.
   // The linker has placed the image of entryother.S in
   // _binary_entryother_start.
-  code = P2V(0x7000);
+  code = p2v(0x7000);
   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
 
   for(c = cpus; c < cpus+ncpu; c++){
     if(c == cpus+cpunum())  // We've started already.
       continue;
 
-    // Tell entryother.S what stack to use, where to enter, and what
+    // Tell entryother.S what stack to use, where to enter, and what 
     // pgdir to use. We cannot use kpgdir yet, because the AP processor
     // is running in low  memory, so we use entrypgdir for the APs too.
     stack = kalloc();
     *(void**)(code-4) = stack + KSTACKSIZE;
     *(void**)(code-8) = mpenter;
-    *(int**)(code-12) = (void *) V2P(entrypgdir);
+    *(int**)(code-12) = (void *) v2p(entrypgdir);
 
-    lapicstartap(c->apicid, V2P(code));
+    lapicstartap(c->id, v2p(code));
 
     // wait for cpu to finish mpmain()
     while(c->started == 0)
@@ -97,11 +98,10 @@
   }
 }
 
-// The boot page table used in entry.S and entryother.S.
-// Page directories (and page tables) must start on page boundaries,
-// hence the __aligned__ attribute.
-// PTE_PS in a page directory entry enables 4Mbyte pages.
-
+// Boot page table used in entry.S and entryother.S.
+// Page directories (and page tables), must start on a page boundary,
+// hence the "__aligned__" attribute.  
+// Use PTE_PS in page directory entry to enable 4Mbyte pages.
 __attribute__((__aligned__(PGSIZE)))
 pde_t entrypgdir[NPDENTRIES] = {
   // Map VA's [0, 4MB) to PA's [0, 4MB)
@@ -113,3 +113,6 @@
 //PAGEBREAK!
 // Blank page.
 //PAGEBREAK!
+// Blank page.
+//PAGEBREAK!
+// Blank page.
diff -ruN xv6-orig/Makefile xv6-public/Makefile
--- xv6-orig/Makefile	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/Makefile	2016-09-25 19:34:38.431452059 +0530
@@ -15,7 +15,6 @@
 	picirq.o\
 	pipe.o\
 	proc.o\
-	sleeplock.o\
 	spinlock.o\
 	string.o\
 	swtch.o\
@@ -75,8 +74,8 @@
 LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
-CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
-#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+#CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
 CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
 ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
 # FreeBSD ld wants ``elf_i386_fbsd''
@@ -173,6 +172,8 @@
 	_usertests\
 	_wc\
 	_zombie\
+	_getsize\
+	_testschd\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -186,6 +187,9 @@
 	.gdbinit \
 	$(UPROGS)
 
+simulate:
+	qemu-system-i386 -serial mon:stdio -hdb fs.img xv6.img -smp cores=4 -m 512
+
 # make a printout
 FILES = $(shell grep -v '^\#' runoff.list)
 PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
@@ -211,13 +215,13 @@
 ifndef CPUS
 CPUS := 2
 endif
-QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
+QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
 qemu: fs.img xv6.img
 	$(QEMU) -serial mon:stdio $(QEMUOPTS)
 
 qemu-memfs: xv6memfs.img
-	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
+	$(QEMU) xv6memfs.img -smp $(CPUS) -m 256
 
 qemu-nox: fs.img xv6.img
 	$(QEMU) -nographic $(QEMUOPTS)
@@ -240,8 +244,8 @@
 # check in that version.
 
 EXTRA=\
-	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	mkfs.c ulib.c user.h cat.c getsize.c echo.c forktest.c grep.c kill.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c testschd.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff -ruN xv6-orig/memide.c xv6-public/memide.c
--- xv6-orig/memide.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/memide.c	2016-09-25 15:51:45.651817076 +0530
@@ -31,7 +31,7 @@
   // no-op
 }
 
-// Sync buf with disk.
+// Sync buf with disk. 
 // If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
 // Else if B_VALID is not set, read buf from disk, set B_VALID.
 void
@@ -39,8 +39,8 @@
 {
   uchar *p;
 
-  if(!holdingsleep(&b->lock))
-    panic("iderw: buf not locked");
+  if(!(b->flags & B_BUSY))
+    panic("iderw: buf not busy");
   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
     panic("iderw: nothing to do");
   if(b->dev != 1)
@@ -49,7 +49,7 @@
     panic("iderw: block out of range");
 
   p = memdisk + b->blockno*BSIZE;
-
+  
   if(b->flags & B_DIRTY){
     b->flags &= ~B_DIRTY;
     memmove(p, b->data, BSIZE);
diff -ruN xv6-orig/memlayout.h xv6-public/memlayout.h
--- xv6-orig/memlayout.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/memlayout.h	2016-09-25 15:51:45.655817076 +0530
@@ -8,6 +8,13 @@
 #define KERNBASE 0x80000000         // First kernel virtual address
 #define KERNLINK (KERNBASE+EXTMEM)  // Address where kernel is linked
 
+#ifndef __ASSEMBLER__
+
+static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }
+static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }
+
+#endif
+
 #define V2P(a) (((uint) (a)) - KERNBASE)
 #define P2V(a) (((void *) (a)) + KERNBASE)
 
diff -ruN xv6-orig/mkfs.c xv6-public/mkfs.c
--- xv6-orig/mkfs.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/mkfs.c	2016-09-25 15:51:45.655817076 +0530
@@ -22,7 +22,7 @@
 
 int nbitmap = FSSIZE/(BSIZE*8) + 1;
 int ninodeblocks = NINODES / IPB + 1;
-int nlog = LOGSIZE;
+int nlog = LOGSIZE;  
 int nmeta;    // Number of meta blocks (boot, sb, nlog, inode, bitmap)
 int nblocks;  // Number of data blocks
 
@@ -134,7 +134,7 @@
       perror(argv[i]);
       exit(1);
     }
-
+    
     // Skip leading _ in name when writing to file system.
     // The binaries are named _rm, _cat, etc. to keep the
     // build operating system from trying to execute them
diff -ruN xv6-orig/mmu.h xv6-public/mmu.h
--- xv6-orig/mmu.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/mmu.h	2016-09-25 15:51:45.655817076 +0530
@@ -1,4 +1,4 @@
-// This file contains definitions for the
+// This file contains definitions for the 
 // x86 memory management unit (MMU).
 
 // Eflags register
@@ -39,7 +39,6 @@
 
 #define CR4_PSE         0x00000010      // Page size extension
 
-// various segment selectors.
 #define SEG_KCODE 1  // kernel code
 #define SEG_KDATA 2  // kernel data+stack
 #define SEG_KCPU  3  // kernel per-cpu data
@@ -47,9 +46,6 @@
 #define SEG_UDATA 5  // user data+stack
 #define SEG_TSS   6  // this process's task state
 
-// cpu->gdt[NSEGS] holds the above segments.
-#define NSEGS     7
-
 //PAGEBREAK!
 #ifndef __ASSEMBLER__
 // Segment Descriptor
@@ -110,7 +106,7 @@
 // | Page Directory |   Page Table   | Offset within Page  |
 // |      Index     |      Index     |                     |
 // +----------------+----------------+---------------------+
-//  \--- PDX(va) --/ \--- PTX(va) --/
+//  \--- PDX(va) --/ \--- PTX(va) --/ 
 
 // page directory index
 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
diff -ruN xv6-orig/mp.c xv6-public/mp.c
--- xv6-orig/mp.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/mp.c	2016-09-25 15:51:45.655817076 +0530
@@ -12,15 +12,22 @@
 #include "proc.h"
 
 struct cpu cpus[NCPU];
+static struct cpu *bcpu;
 int ismp;
 int ncpu;
 uchar ioapicid;
 
+int
+mpbcpu(void)
+{
+  return bcpu-cpus;
+}
+
 static uchar
 sum(uchar *addr, int len)
 {
   int i, sum;
-
+  
   sum = 0;
   for(i=0; i<len; i++)
     sum += addr[i];
@@ -33,7 +40,7 @@
 {
   uchar *e, *p, *addr;
 
-  addr = P2V(a);
+  addr = p2v(a);
   e = addr+len;
   for(p = addr; p < e; p += sizeof(struct mp))
     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
@@ -78,7 +85,7 @@
 
   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
     return 0;
-  conf = (struct mpconf*) P2V((uint) mp->physaddr);
+  conf = (struct mpconf*) p2v((uint) mp->physaddr);
   if(memcmp(conf, "PCMP", 4) != 0)
     return 0;
   if(conf->version != 1 && conf->version != 4)
@@ -98,6 +105,7 @@
   struct mpproc *proc;
   struct mpioapic *ioapic;
 
+  bcpu = &cpus[0];
   if((conf = mpconfig(&mp)) == 0)
     return;
   ismp = 1;
@@ -106,10 +114,14 @@
     switch(*p){
     case MPPROC:
       proc = (struct mpproc*)p;
-      if(ncpu < NCPU) {
-        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
-        ncpu++;
+      if(ncpu != proc->apicid){
+        cprintf("mpinit: ncpu=%d apicid=%d\n", ncpu, proc->apicid);
+        ismp = 0;
       }
+      if(proc->flags & MPBOOT)
+        bcpu = &cpus[ncpu];
+      cpus[ncpu].id = ncpu;
+      ncpu++;
       p += sizeof(struct mpproc);
       continue;
     case MPIOAPIC:
@@ -123,8 +135,8 @@
       p += 8;
       continue;
     default:
+      cprintf("mpinit: unknown config type %x\n", *p);
       ismp = 0;
-      break;
     }
   }
   if(!ismp){
diff -ruN xv6-orig/picirq.c xv6-public/picirq.c
--- xv6-orig/picirq.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/picirq.c	2016-09-25 15:51:45.655817076 +0530
@@ -82,6 +82,3 @@
   if(irqmask != 0xFFFF)
     picsetmask(irqmask);
 }
-
-//PAGEBREAK!
-// Blank page.
diff -ruN xv6-orig/pipe.c xv6-public/pipe.c
--- xv6-orig/pipe.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/pipe.c	2016-09-25 15:51:45.655817076 +0530
@@ -4,9 +4,8 @@
 #include "mmu.h"
 #include "proc.h"
 #include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
 #include "file.h"
+#include "spinlock.h"
 
 #define PIPESIZE 512
 
diff -ruN xv6-orig/proc.c xv6-public/proc.c
--- xv6-orig/proc.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/proc.c	2016-09-25 21:06:16.323301992 +0530
@@ -38,29 +38,26 @@
   char *sp;
 
   acquire(&ptable.lock);
-
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == UNUSED)
       goto found;
-
   release(&ptable.lock);
   return 0;
 
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
-
   release(&ptable.lock);
 
   // Allocate kernel stack.
-  if((p->kstack = kalloc()) == 0){
+  if ((p->kstack = kalloc()) == 0) {
     p->state = UNUSED;
     return 0;
   }
   sp = p->kstack + KSTACKSIZE;
 
   // Leave room for trap frame.
-  sp -= sizeof *p->tf;
+  sp -= sizeof * p->tf;
   p->tf = (struct trapframe*)sp;
 
   // Set up new context to start executing at forkret,
@@ -68,9 +65,9 @@
   sp -= 4;
   *(uint*)sp = (uint)trapret;
 
-  sp -= sizeof *p->context;
+  sp -= sizeof * p->context;
   p->context = (struct context*)sp;
-  memset(p->context, 0, sizeof *p->context);
+  memset(p->context, 0, sizeof * p->context);
   p->context->eip = (uint)forkret;
 
   return p;
@@ -85,9 +82,8 @@
   extern char _binary_initcode_start[], _binary_initcode_size[];
 
   p = allocproc();
-  
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if ((p->pgdir = setupkvm()) == 0)
     panic("userinit: out of memory?");
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
@@ -103,15 +99,10 @@
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
-  // this assignment to p->state lets other cores
-  // run this process. the acquire forces the above
-  // writes to be visible, and the lock is also needed
-  // because the assignment might not be atomic.
-  acquire(&ptable.lock);
-
   p->state = RUNNABLE;
 
-  release(&ptable.lock);
+  p->priority = 1 ;
+
 }
 
 // Grow current process's memory by n bytes.
@@ -122,11 +113,11 @@
   uint sz;
 
   sz = proc->sz;
-  if(n > 0){
-    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+  if (n > 0) {
+    if ((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
       return -1;
-  } else if(n < 0){
-    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+  } else if (n < 0) {
+    if ((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
       return -1;
   }
   proc->sz = sz;
@@ -144,12 +135,11 @@
   struct proc *np;
 
   // Allocate process.
-  if((np = allocproc()) == 0){
+  if ((np = allocproc()) == 0)
     return -1;
-  }
 
   // Copy process state from p.
-  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+  if ((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0) {
     kfree(np->kstack);
     np->kstack = 0;
     np->state = UNUSED;
@@ -159,11 +149,14 @@
   np->parent = proc;
   *np->tf = *proc->tf;
 
+  //change priority here
+  np->priority = proc->priority;
+
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
-  for(i = 0; i < NOFILE; i++)
-    if(proc->ofile[i])
+  for (i = 0; i < NOFILE; i++)
+    if (proc->ofile[i])
       np->ofile[i] = filedup(proc->ofile[i]);
   np->cwd = idup(proc->cwd);
 
@@ -171,10 +164,9 @@
 
   pid = np->pid;
 
+  // lock to force the compiler to emit the np->state write last.
   acquire(&ptable.lock);
-
   np->state = RUNNABLE;
-
   release(&ptable.lock);
 
   return pid;
@@ -189,12 +181,12 @@
   struct proc *p;
   int fd;
 
-  if(proc == initproc)
+  if (proc == initproc)
     panic("init exiting");
 
   // Close all open files.
-  for(fd = 0; fd < NOFILE; fd++){
-    if(proc->ofile[fd]){
+  for (fd = 0; fd < NOFILE; fd++) {
+    if (proc->ofile[fd]) {
       fileclose(proc->ofile[fd]);
       proc->ofile[fd] = 0;
     }
@@ -211,10 +203,10 @@
   wakeup1(proc->parent);
 
   // Pass abandoned children to init.
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->parent == proc){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+    if (p->parent == proc) {
       p->parent = initproc;
-      if(p->state == ZOMBIE)
+      if (p->state == ZOMBIE)
         wakeup1(initproc);
     }
   }
@@ -234,31 +226,31 @@
   int havekids, pid;
 
   acquire(&ptable.lock);
-  for(;;){
-    // Scan through table looking for exited children.
+  for (;;) {
+    // Scan through table looking for zombie children.
     havekids = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->parent != proc)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->parent != proc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      if (p->state == ZOMBIE) {
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
         p->kstack = 0;
         freevm(p->pgdir);
+        p->state = UNUSED;
         p->pid = 0;
         p->parent = 0;
         p->name[0] = 0;
         p->killed = 0;
-        p->state = UNUSED;
         release(&ptable.lock);
         return pid;
       }
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || proc->killed){
+    if (!havekids || proc->killed) {
       release(&ptable.lock);
       return -1;
     }
@@ -272,62 +264,72 @@
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
 // Scheduler never returns.  It loops, doing:
-//  - choose a process to run
+//  - choose process with maximum priority among RUNNABLE processes
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
 void
 scheduler(void)
 {
-  struct proc *p;
+  struct proc *p, *f;
 
-  for(;;){
+  for (;;) {
     // Enable interrupts on this processor.
     sti();
 
-    // Loop over process table looking for process to run.
+    int maxp = 0, first = 1;
+    // Loop over process table looking for pfirstrocess to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+    for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+      if (p->state != RUNNABLE)
         continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-      swtch(&cpu->scheduler, p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      proc = 0;
+      else {
+        if (first) {
+          f = p;
+          maxp = p->priority;
+          first = 0;
+          continue;
+        }
+        if (p->priority > maxp ) {
+          f = p;
+          maxp = p->priority;
+        }
+      }
     }
+
+    //cprintf("Scheduler here !\n New proc pid %d priority %d.", f->pid, f->priority );
+    // Switch to chosen process.  It is the process's job
+    // to release ptable.lock and then reacquire it
+    // before jumping back to us.
+
+    proc = f;
+    switchuvm(f);
+    f->state = RUNNING;
+    swtch(&cpu->scheduler, proc->context);
+    switchkvm();
+
+    // Process is done running for now.
+    // It should have changed its p->state before coming back.
+    proc = 0;
     release(&ptable.lock);
 
   }
 }
 
 // Enter scheduler.  Must hold only ptable.lock
-// and have changed proc->state. Saves and restores
-// intena because intena is a property of this
-// kernel thread, not this CPU. It should
-// be proc->intena and proc->ncli, but that would
-// break in the few places where a lock is held but
-// there's no process.
+// and have changed proc->state.
 void
 sched(void)
 {
   int intena;
 
-  if(!holding(&ptable.lock))
+  if (!holding(&ptable.lock))
     panic("sched ptable.lock");
-  if(cpu->ncli != 1)
+  if (cpu->ncli != 1)
     panic("sched locks");
-  if(proc->state == RUNNING)
+  if (proc->state == RUNNING)
     panic("sched running");
-  if(readeflags()&FL_IF)
+  if (readeflags()&FL_IF)
     panic("sched interruptible");
   intena = cpu->intena;
   swtch(&proc->context, cpu->scheduler);
@@ -370,10 +372,10 @@
 void
 sleep(void *chan, struct spinlock *lk)
 {
-  if(proc == 0)
+  if (proc == 0)
     panic("sleep");
 
-  if(lk == 0)
+  if (lk == 0)
     panic("sleep without lk");
 
   // Must acquire ptable.lock in order to
@@ -382,7 +384,7 @@
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
+  if (lk != &ptable.lock) { //DOC: sleeplock0
     acquire(&ptable.lock);  //DOC: sleeplock1
     release(lk);
   }
@@ -396,7 +398,7 @@
   proc->chan = 0;
 
   // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
+  if (lk != &ptable.lock) { //DOC: sleeplock2
     release(&ptable.lock);
     acquire(lk);
   }
@@ -410,8 +412,8 @@
 {
   struct proc *p;
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if (p->state == SLEEPING && p->chan == chan)
       p->state = RUNNABLE;
 }
 
@@ -433,11 +435,11 @@
   struct proc *p;
 
   acquire(&ptable.lock);
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->pid == pid){
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+    if (p->pid == pid) {
       p->killed = 1;
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
+      if (p->state == SLEEPING)
         p->state = RUNNABLE;
       release(&ptable.lock);
       return 0;
@@ -455,31 +457,41 @@
 procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
-  [EMBRYO]    "embryo",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
+    [UNUSED]    "unused",
+    [EMBRYO]    "embryo",
+    [SLEEPING]  "sleep ",
+    [RUNNABLE]  "runble",
+    [RUNNING]   "run   ",
+    [ZOMBIE]    "zombie"
   };
   int i;
   struct proc *p;
   char *state;
   uint pc[10];
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-    if(p->state == UNUSED)
+  for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
+    if (p->state == UNUSED)
       continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
     cprintf("%d %s %s", p->pid, state, p->name);
-    if(p->state == SLEEPING){
-      getcallerpcs((uint*)p->context->ebp+2, pc);
-      for(i=0; i<10 && pc[i] != 0; i++)
+    if (p->state == SLEEPING) {
+      getcallerpcs((uint*)p->context->ebp + 2, pc);
+      for (i = 0; i < 10 && pc[i] != 0; i++)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
   }
 }
+
+int
+setprio(int prio){
+
+  acquire(&ptable.lock);
+  proc->priority = prio;
+  release(&ptable.lock);
+  
+  return 0;
+}
diff -ruN xv6-orig/proc.h xv6-public/proc.h
--- xv6-orig/proc.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/proc.h	2016-09-25 15:51:45.655817076 +0530
@@ -1,13 +1,16 @@
+// Segments in proc->gdt.
+#define NSEGS     7
+
 // Per-CPU state
 struct cpu {
-  uchar apicid;                // Local APIC ID
+  uchar id;                    // Local APIC ID; index into cpus[] below
   struct context *scheduler;   // swtch() here to enter scheduler
   struct taskstate ts;         // Used by x86 to find stack for interrupt
   struct segdesc gdt[NSEGS];   // x86 global descriptor table
   volatile uint started;       // Has the CPU started?
   int ncli;                    // Depth of pushcli nesting.
   int intena;                  // Were interrupts enabled before pushcli?
-
+  
   // Cpu-local storage variables; see below
   struct cpu *cpu;
   struct proc *proc;           // The currently-running process.
@@ -63,6 +66,7 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int priority;                // priority of process  
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff -ruN xv6-orig/README xv6-public/README
--- xv6-orig/README	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/README	2016-09-25 15:51:45.647817076 +0530
@@ -6,7 +6,7 @@
 
 xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
 to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
-2000)). See also http://pdos.csail.mit.edu/6.828/2016/xv6.html, which
+2000)). See also http://pdos.csail.mit.edu/6.828/2014/xv6.html, which
 provides pointers to on-line resources for v6.
 
 xv6 borrows code from the following sources:
@@ -15,36 +15,32 @@
     FreeBSD (ioapic.c)
     NetBSD (console.c)
 
-The following people have made contributions: Russ Cox (context switching,
-locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
-Clements.
-
-We are also grateful for the bug reports and patches contributed by Silas
-Boyd-Wickizer, Mike CAT, Nelson Elhage, Nathaniel Filardo, Peter Froehlich,
-Yakir Goaran, Shivam Handa, Bryan Henry, Jim Huang, Anders Kaseorg, kehao95,
-Eddie Kohler, Imbar Marinescu, Yandong Mao, Hitoshi Mitake, Carmi Merimovich,
-Joel Nider, Greg Price, Ayan Shafqat, Eldar Sehayek, Yongming Shen, Cam Tenny,
-Rafael Ubal, Warren Toomey, Stephen Tu, Pablo Ventura, Xi Wang, Keiichi
-Watanabe, Nicolas Wolovick, Jindong Zhang, and Zou Chang Wei.
+The following people have made contributions:
+    Russ Cox (context switching, locking)
+    Cliff Frey (MP)
+    Xiao Yu (MP)
+    Nickolai Zeldovich
+    Austin Clements
+
+In addition, we are grateful for the bug reports and patches contributed by
+Silas Boyd-Wickizer, Peter Froehlich, Shivam Handa, Anders Kaseorg, Eddie
+Kohler, Yandong Mao, Hitoshi Mitake, Carmi Merimovich, Joel Nider, Greg Price,
+Eldar Sehayek, Yongming Shen, Stephen Tu, and Zouchangwei.
 
 The code in the files that constitute xv6 is
-Copyright 2006-2016 Frans Kaashoek, Robert Morris, and Russ Cox.
+Copyright 2006-2014 Frans Kaashoek, Robert Morris, and Russ Cox.
 
 ERROR REPORTS
 
-If you spot errors or have suggestions for improvement, please send email to
-Frans Kaashoek and Robert Morris (kaashoek,rtm@csail.mit.edu).  If you have
-suggestions for improvements, please keep in mind that the main purpose of xv6
-is as a teaching operating system for MIT's 6.828. For example, we are in
-particular interested in simplifications and clarifications, instead of
-suggestions for new systems calls, more portability, etc.
+If you spot errors or have suggestions for improvement, please send
+email to Frans Kaashoek and Robert Morris (kaashoek,rtm@csail.mit.edu). 
 
 BUILDING AND RUNNING XV6
 
 To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run "make".
 On non-x86 or non-ELF machines (like OS X, even on x86), you will
 need to install a cross-compiler gcc suite capable of producing x86 ELF
-binaries.  See http://pdos.csail.mit.edu/6.828/2016/tools.html.
+binaries.  See http://pdos.csail.mit.edu/6.828/2014/tools.html.
 Then run "make TOOLPREFIX=i386-jos-elf-".
 
 To run xv6, install the QEMU PC simulators.  To run in QEMU, run "make qemu".
diff -ruN xv6-orig/runoff.list xv6-public/runoff.list
--- xv6-orig/runoff.list	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/runoff.list	2016-09-25 15:51:45.655817076 +0530
@@ -35,14 +35,12 @@
 
 # file system
 buf.h
-sleeplock.h
 fcntl.h
 stat.h
 fs.h
 file.h
 ide.c
 bio.c
-sleeplock.c
 log.c
 fs.c
 file.c
diff -ruN xv6-orig/sh.c xv6-public/sh.c
--- xv6-orig/sh.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/sh.c	2016-09-25 15:51:45.655817076 +0530
@@ -66,7 +66,7 @@
 
   if(cmd == 0)
     exit();
-
+  
   switch(cmd->type){
   default:
     panic("runcmd");
@@ -120,7 +120,7 @@
     wait();
     wait();
     break;
-
+    
   case BACK:
     bcmd = (struct backcmd*)cmd;
     if(fork1() == 0)
@@ -146,19 +146,20 @@
 {
   static char buf[100];
   int fd;
-
-  // Ensure that three file descriptors are open.
+  
+  // Assumes three file descriptors open.
   while((fd = open("console", O_RDWR)) >= 0){
     if(fd >= 3){
       close(fd);
       break;
     }
   }
-
+  
   // Read and run input commands.
   while(getcmd(buf, sizeof(buf)) >= 0){
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
-      // Chdir must be called by the parent, not the child.
+      // Clumsy but will have to do for now.
+      // Chdir has no effect on the parent if run in the child.
       buf[strlen(buf)-1] = 0;  // chop \n
       if(chdir(buf+3) < 0)
         printf(2, "cannot cd %s\n", buf+3);
@@ -182,7 +183,7 @@
 fork1(void)
 {
   int pid;
-
+  
   pid = fork();
   if(pid == -1)
     panic("fork");
@@ -267,7 +268,7 @@
 {
   char *s;
   int ret;
-
+  
   s = *ps;
   while(s < es && strchr(whitespace, *s))
     s++;
@@ -300,7 +301,7 @@
   }
   if(eq)
     *eq = s;
-
+  
   while(s < es && strchr(whitespace, *s))
     s++;
   *ps = s;
@@ -311,7 +312,7 @@
 peek(char **ps, char *es, char *toks)
 {
   char *s;
-
+  
   s = *ps;
   while(s < es && strchr(whitespace, *s))
     s++;
@@ -419,7 +420,7 @@
   int tok, argc;
   struct execcmd *cmd;
   struct cmd *ret;
-
+  
   if(peek(ps, es, "("))
     return parseblock(ps, es);
 
@@ -458,7 +459,7 @@
 
   if(cmd == 0)
     return 0;
-
+  
   switch(cmd->type){
   case EXEC:
     ecmd = (struct execcmd*)cmd;
@@ -477,7 +478,7 @@
     nulterminate(pcmd->left);
     nulterminate(pcmd->right);
     break;
-
+    
   case LIST:
     lcmd = (struct listcmd*)cmd;
     nulterminate(lcmd->left);
diff -ruN xv6-orig/sleeplock.c xv6-public/sleeplock.c
--- xv6-orig/sleeplock.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/sleeplock.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,56 +0,0 @@
-// Sleeping locks
-
-#include "types.h"
-#include "defs.h"
-#include "param.h"
-#include "x86.h"
-#include "memlayout.h"
-#include "mmu.h"
-#include "proc.h"
-#include "spinlock.h"
-#include "sleeplock.h"
-
-void
-initsleeplock(struct sleeplock *lk, char *name)
-{
-  initlock(&lk->lk, "sleep lock");
-  lk->name = name;
-  lk->locked = 0;
-  lk->pid = 0;
-}
-
-void
-acquiresleep(struct sleeplock *lk)
-{
-  acquire(&lk->lk);
-  while (lk->locked) {
-    sleep(lk, &lk->lk);
-  }
-  lk->locked = 1;
-  lk->pid = proc->pid;
-  release(&lk->lk);
-}
-
-void
-releasesleep(struct sleeplock *lk)
-{
-  acquire(&lk->lk);
-  lk->locked = 0;
-  lk->pid = 0;
-  wakeup(lk);
-  release(&lk->lk);
-}
-
-int
-holdingsleep(struct sleeplock *lk)
-{
-  int r;
-  
-  acquire(&lk->lk);
-  r = lk->locked;
-  release(&lk->lk);
-  return r;
-}
-
-
-
diff -ruN xv6-orig/sleeplock.h xv6-public/sleeplock.h
--- xv6-orig/sleeplock.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/sleeplock.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,10 +0,0 @@
-// Long-term locks for processes
-struct sleeplock {
-  uint locked;       // Is the lock held?
-  struct spinlock lk; // spinlock protecting this sleep lock
-  
-  // For debugging:
-  char *name;        // Name of lock.
-  int pid;           // Process holding lock
-};
-
diff -ruN xv6-orig/spinlock.c xv6-public/spinlock.c
--- xv6-orig/spinlock.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/spinlock.c	2016-09-25 15:51:45.655817076 +0530
@@ -29,14 +29,11 @@
     panic("acquire");
 
   // The xchg is atomic.
+  // It also serializes, so that reads after acquire are not
+  // reordered before it. 
   while(xchg(&lk->locked, 1) != 0)
     ;
 
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that the critical section's memory
-  // references happen after the lock is acquired.
-  __sync_synchronize();
-
   // Record info about lock acquisition for debugging.
   lk->cpu = cpu;
   getcallerpcs(&lk, lk->pcs);
@@ -52,17 +49,16 @@
   lk->pcs[0] = 0;
   lk->cpu = 0;
 
-  // Tell the C compiler and the processor to not move loads or stores
-  // past this point, to ensure that all the stores in the critical
-  // section are visible to other cores before the lock is released.
-  // Both the C compiler and the hardware may re-order loads and
-  // stores; __sync_synchronize() tells them both not to.
-  __sync_synchronize();
-
-  // Release the lock, equivalent to lk->locked = 0.
-  // This code can't use a C assignment, since it might
-  // not be atomic. A real OS would use C atomics here.
-  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
+  // The xchg serializes, so that reads before release are 
+  // not reordered after it.  The 1996 PentiumPro manual (Volume 3,
+  // 7.2) says reads can be carried out speculatively and in
+  // any order, which implies we need to serialize here.
+  // But the 2007 Intel 64 Architecture Memory Ordering White
+  // Paper says that Intel 64 and IA-32 will not move a load
+  // after a store. So lock->locked = 0 would work here.
+  // The xchg being asm volatile ensures gcc emits it after
+  // the above assignments (and after the critical section).
+  xchg(&lk->locked, 0);
 
   popcli();
 }
@@ -73,7 +69,7 @@
 {
   uint *ebp;
   int i;
-
+  
   ebp = (uint*)v - 2;
   for(i = 0; i < 10; i++){
     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
@@ -101,12 +97,11 @@
 pushcli(void)
 {
   int eflags;
-
+  
   eflags = readeflags();
   cli();
-  if(cpu->ncli == 0)
+  if(cpu->ncli++ == 0)
     cpu->intena = eflags & FL_IF;
-  cpu->ncli += 1;
 }
 
 void
diff -ruN xv6-orig/spinlock.h xv6-public/spinlock.h
--- xv6-orig/spinlock.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/spinlock.h	2016-09-25 15:51:45.655817076 +0530
@@ -1,7 +1,7 @@
 // Mutual exclusion lock.
 struct spinlock {
   uint locked;       // Is the lock held?
-
+  
   // For debugging:
   char *name;        // Name of lock.
   struct cpu *cpu;   // The cpu holding the lock.
diff -ruN xv6-orig/stressfs.c xv6-public/stressfs.c
--- xv6-orig/stressfs.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/stressfs.c	2016-09-25 15:51:45.655817076 +0530
@@ -44,6 +44,6 @@
   close(fd);
 
   wait();
-
+  
   exit();
 }
diff -ruN xv6-orig/string.c xv6-public/string.c
--- xv6-orig/string.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/string.c	2016-09-25 15:51:45.655817076 +0530
@@ -16,7 +16,7 @@
 memcmp(const void *v1, const void *v2, uint n)
 {
   const uchar *s1, *s2;
-
+  
   s1 = v1;
   s2 = v2;
   while(n-- > 0){
@@ -69,7 +69,7 @@
 strncpy(char *s, const char *t, int n)
 {
   char *os;
-
+  
   os = s;
   while(n-- > 0 && (*s++ = *t++) != 0)
     ;
@@ -83,7 +83,7 @@
 safestrcpy(char *s, const char *t, int n)
 {
   char *os;
-
+  
   os = s;
   if(n <= 0)
     return os;
diff -ruN xv6-orig/syscall.c xv6-public/syscall.c
--- xv6-orig/syscall.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/syscall.c	2016-09-25 17:26:04.559662613 +0530
@@ -49,13 +49,13 @@
 }
 
 // Fetch the nth word-sized system call argument as a pointer
-// to a block of memory of size bytes.  Check that the pointer
+// to a block of memory of size n bytes.  Check that the pointer
 // lies within the process address space.
 int
 argptr(int n, char **pp, int size)
 {
   int i;
-
+  
   if(argint(n, &i) < 0)
     return -1;
   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
@@ -98,6 +98,9 @@
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_getppid(void);
+extern int sys_setprio(void);
+extern int sys_getprio(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -121,6 +124,9 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_getppid]   sys_getppid,
+[SYS_setprio]   sys_setprio,
+[SYS_getprio]   sys_getprio,
 };
 
 void
diff -ruN xv6-orig/syscall.h xv6-public/syscall.h
--- xv6-orig/syscall.h	2016-09-25 21:09:53.611296061 +0530
+++ xv6-public/syscall.h	2016-09-25 17:11:44.435686091 +0530
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_getppid  22
+#define SYS_getprio  23
+#define SYS_setprio  24
diff -ruN xv6-orig/sysfile.c xv6-public/sysfile.c
--- xv6-orig/sysfile.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/sysfile.c	2016-09-25 15:51:45.655817076 +0530
@@ -11,8 +11,6 @@
 #include "mmu.h"
 #include "proc.h"
 #include "fs.h"
-#include "spinlock.h"
-#include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
 
@@ -56,7 +54,7 @@
 {
   struct file *f;
   int fd;
-
+  
   if(argfd(0, 0, &f) < 0)
     return -1;
   if((fd=fdalloc(f)) < 0)
@@ -94,7 +92,7 @@
 {
   int fd;
   struct file *f;
-
+  
   if(argfd(0, &fd, &f) < 0)
     return -1;
   proc->ofile[fd] = 0;
@@ -107,7 +105,7 @@
 {
   struct file *f;
   struct stat *st;
-
+  
   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
     return -1;
   return filestat(f, st);
@@ -353,10 +351,11 @@
 {
   struct inode *ip;
   char *path;
+  int len;
   int major, minor;
-
+  
   begin_op();
-  if((argstr(0, &path)) < 0 ||
+  if((len=argstr(0, &path)) < 0 ||
      argint(1, &major) < 0 ||
      argint(2, &minor) < 0 ||
      (ip = create(path, T_DEV, major, minor)) == 0){
diff -ruN xv6-orig/sysproc.c xv6-public/sysproc.c
--- xv6-orig/sysproc.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/sysproc.c	2016-09-25 17:54:59.463615258 +0530
@@ -61,7 +61,7 @@
 {
   int n;
   uint ticks0;
-
+  
   if(argint(0, &n) < 0)
     return -1;
   acquire(&tickslock);
@@ -83,9 +83,35 @@
 sys_uptime(void)
 {
   uint xticks;
-
+  
   acquire(&tickslock);
   xticks = ticks;
   release(&tickslock);
   return xticks;
 }
+
+
+//get size of current process
+int
+sys_getppid(void)
+{
+  return proc->parent->pid;
+}
+
+// set priority of prcess as n
+int
+sys_setprio(void){
+
+  int prio;
+  if(argint(0, &prio) < 0)
+    return -1;
+  return setprio(prio);
+}
+
+// get priority of process
+int
+sys_getprio(void){
+
+    return proc->priority;
+}
+
diff -ruN xv6-orig/testschd.c xv6-public/testschd.c
--- xv6-orig/testschd.c	1970-01-01 05:30:00.000000000 +0530
+++ xv6-public/testschd.c	2016-09-25 19:26:38.799465151 +0530
@@ -0,0 +1,112 @@
+//test scheduler here
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fcntl.h"
+
+int
+main(void)
+{
+
+  printf(1, "Testing starts here. \n");
+  printf(1, "Process info format: [<PID> <PPID> <PRIO>] \n");
+
+  {
+  printf(1, "\nStarting test #1: \n=============================\n");
+  setprio(100);
+  int n = 10, i = 0;
+  printf(1, "[%d, %d, %d] started\n", getpid(), getppid(), getprio());
+
+  for (; i < n ; i++) {
+
+    int k = fork();
+    if (k == -1){
+      printf(2, "fork failed\n");
+    }
+
+    if (k){
+      //parent
+      continue;
+    }
+    else{
+      //child
+      setprio(i+5);
+      printf(1, "[%d, %d, %d] starting\n", getpid(), getppid(), getprio());
+
+      int j = 0;
+      for (; j < 1000000; j++){}
+
+      printf(1, "[%d, %d, %d] exiting\n", getpid(), getppid(), getprio());
+
+      exit();
+    }
+
+  }
+  int z_id;
+  while ((z_id = wait()) != -1){
+    printf(1, "[%d] reaped\n", z_id);
+  }
+  printf(1, "=============================\nTest #1 done\n");
+  }
+
+  {
+  printf(1, "\nStarting test #2: \n=============================\n");
+  setprio(100);
+  int n = 10, i = 0;
+  printf(1, "[%d, %d, %d] started\n", getpid(), getppid(), getprio());
+
+  for (; i < n ; i++) {
+
+    int k = fork();
+    if (k == -1){
+      printf(2, "fork failed\n");
+    }
+
+    if (k){
+      //parent
+      continue;
+    }
+    else{
+      //child
+      setprio(i+5);
+      printf(1, "[%d, %d, %d] starting\n", getpid(), getppid(), getprio());
+
+      int fd1, fd2;
+      if((fd1 = open("dump", O_WRONLY|O_CREATE)) < 0){
+        printf(2, "open %s failed\n", "dump");
+        exit();
+      }
+      if((fd2 = open("dump", O_RDONLY|O_CREATE)) < 0){
+        printf(2, "open %s failed\n", "dump");
+        exit();
+      }
+
+
+      int j = 0;
+      int temp = 100;
+      char buf[temp+1];
+      for (; j < 100; j++){
+        temp = read(fd2, buf, temp);
+        printf(fd1, "%d\n", j);
+      }
+
+      printf(1, "[%d, %d, %d] exiting\n", getpid(), getppid(), getprio());
+
+      close(fd1);
+      close(fd2);
+      exit();
+    }
+
+  }
+  int z_id;
+  while ((z_id = wait()) != -1){
+    printf(1, "[%d] reaped\n", z_id);
+  }
+  printf(1, "=============================\nTest #2 done\n");
+  }
+  printf(1, "[%d, %d, %d] exiting\n", getpid(), getppid(), getprio());
+
+
+  exit();
+
+}
\ No newline at end of file
diff -ruN xv6-orig/trap.c xv6-public/trap.c
--- xv6-orig/trap.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/trap.c	2016-09-25 15:51:45.659817075 +0530
@@ -22,7 +22,7 @@
   for(i = 0; i < 256; i++)
     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
-
+  
   initlock(&tickslock, "time");
 }
 
@@ -48,7 +48,7 @@
 
   switch(tf->trapno){
   case T_IRQ0 + IRQ_TIMER:
-    if(cpunum() == 0){
+    if(cpu->id == 0){
       acquire(&tickslock);
       ticks++;
       wakeup(&ticks);
@@ -74,28 +74,28 @@
   case T_IRQ0 + 7:
   case T_IRQ0 + IRQ_SPURIOUS:
     cprintf("cpu%d: spurious interrupt at %x:%x\n",
-            cpunum(), tf->cs, tf->eip);
+            cpu->id, tf->cs, tf->eip);
     lapiceoi();
     break;
-
+   
   //PAGEBREAK: 13
   default:
     if(proc == 0 || (tf->cs&3) == 0){
       // In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
-              tf->trapno, cpunum(), tf->eip, rcr2());
+              tf->trapno, cpu->id, tf->eip, rcr2());
       panic("trap");
     }
     // In user space, assume process misbehaved.
     cprintf("pid %d %s: trap %d err %d on cpu %d "
             "eip 0x%x addr 0x%x--kill proc\n",
-            proc->pid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
+            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
             rcr2());
     proc->killed = 1;
   }
 
   // Force process exit if it has been killed and is in user space.
-  // (If it is still executing in the kernel, let it keep running
+  // (If it is still executing in the kernel, let it keep running 
   // until it gets to the regular system call return.)
   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
     exit();
diff -ruN xv6-orig/uart.c xv6-public/uart.c
--- xv6-orig/uart.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/uart.c	2016-09-25 15:51:45.659817075 +0530
@@ -5,7 +5,6 @@
 #include "param.h"
 #include "traps.h"
 #include "spinlock.h"
-#include "sleeplock.h"
 #include "fs.h"
 #include "file.h"
 #include "mmu.h"
@@ -23,7 +22,7 @@
 
   // Turn off the FIFO
   outb(COM1+2, 0);
-
+  
   // 9600 baud, 8 data bits, 1 stop bit, parity off.
   outb(COM1+3, 0x80);    // Unlock divisor
   outb(COM1+0, 115200/9600);
@@ -43,7 +42,7 @@
   inb(COM1+0);
   picenable(IRQ_COM1);
   ioapicenable(IRQ_COM1, 0);
-
+  
   // Announce that we're here.
   for(p="xv6...\n"; *p; p++)
     uartputc(*p);
diff -ruN xv6-orig/ulib.c xv6-public/ulib.c
--- xv6-orig/ulib.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/ulib.c	2016-09-25 15:51:45.659817075 +0530
@@ -96,7 +96,7 @@
 memmove(void *vdst, void *vsrc, int n)
 {
   char *dst, *src;
-
+  
   dst = vdst;
   src = vsrc;
   while(n-- > 0)
diff -ruN xv6-orig/user.h xv6-public/user.h
--- xv6-orig/user.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/user.h	2016-09-25 17:26:20.075662190 +0530
@@ -23,6 +23,10 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int getppid(void);
+int setprio(int);
+int getprio(void);
+
 
 // ulib.c
 int stat(char*, struct stat*);
diff -ruN xv6-orig/usertests.c xv6-public/usertests.c
--- xv6-orig/usertests.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/usertests.c	2016-09-25 15:51:45.659817075 +0530
@@ -539,7 +539,7 @@
         printf(1, "create failed\n");
         exit();
       }
-
+      
       memset(buf, '0'+pi, 512);
       for(i = 0; i < 12; i++){
         if((n = write(fd, buf, 500)) != 500){
@@ -882,7 +882,7 @@
 
   if(pid)
     wait();
-  else
+  else 
     exit();
 
   printf(1, "linkunlink ok\n");
@@ -951,7 +951,7 @@
   }
   write(fd, "ff", 2);
   close(fd);
-
+  
   if(unlink("dd") >= 0){
     printf(1, "unlink dd (non-empty dir) succeeded!\n");
     exit();
@@ -1390,24 +1390,24 @@
     if(pid == 0)
       exit();
   }
-
+  
   if(n == 1000){
     printf(1, "fork claimed to work 1000 times!\n");
     exit();
   }
-
+  
   for(; n > 0; n--){
     if(wait() < 0){
       printf(1, "wait stopped early\n");
       exit();
     }
   }
-
+  
   if(wait() != -1){
     printf(1, "wait got too many\n");
     exit();
   }
-
+  
   printf(1, "fork test OK\n");
 }
 
@@ -1424,7 +1424,7 @@
   // can one sbrk() less than a page?
   a = sbrk(0);
   int i;
-  for(i = 0; i < 5000; i++){
+  for(i = 0; i < 5000; i++){ 
     b = sbrk(1);
     if(b != a){
       printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
@@ -1453,7 +1453,7 @@
   a = sbrk(0);
   amt = (BIG) - (uint)a;
   p = sbrk(amt);
-  if (p != a) {
+  if (p != a) { 
     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
     exit();
   }
@@ -1492,7 +1492,7 @@
     printf(stdout, "sbrk downsize failed, a %x c %x\n", a, c);
     exit();
   }
-
+  
   // can we read the kernel's memory?
   for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
     ppid = getpid();
@@ -1695,35 +1695,6 @@
   printf(1, "fsfull test finished\n");
 }
 
-void
-uio()
-{
-  #define RTC_ADDR 0x70
-  #define RTC_DATA 0x71
-
-  ushort port = 0;
-  uchar val = 0;
-  int pid;
-
-  printf(1, "uio test\n");
-  pid = fork();
-  if(pid == 0){
-    port = RTC_ADDR;
-    val = 0x09;  /* year */
-    /* http://wiki.osdev.org/Inline_Assembly/Examples */
-    asm volatile("outb %0,%1"::"a"(val), "d" (port));
-    port = RTC_DATA;
-    asm volatile("inb %1,%0" : "=a" (val) : "d" (port));
-    printf(1, "uio: uio succeeded; test FAILED\n");
-    exit();
-  } else if(pid < 0){
-    printf (1, "fork failed\n");
-    exit();
-  }
-  wait();
-  printf(1, "uio test done\n");
-}
-
 unsigned long randstate = 1;
 unsigned int
 rand()
@@ -1780,9 +1751,6 @@
   iref();
   forktest();
   bigdir(); // slow
-
-  uio();
-
   exectest();
 
   exit();
diff -ruN xv6-orig/usys.S xv6-public/usys.S
--- xv6-orig/usys.S	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/usys.S	2016-09-25 17:15:07.111680558 +0530
@@ -29,3 +29,7 @@
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(getppid)
+SYSCALL(setprio)
+SYSCALL(getprio)
+
diff -ruN xv6-orig/vm.c xv6-public/vm.c
--- xv6-orig/vm.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/vm.c	2016-09-25 15:51:45.659817075 +0530
@@ -9,6 +9,7 @@
 
 extern char data[];  // defined by kernel.ld
 pde_t *kpgdir;  // for use in scheduler()
+struct segdesc gdt[NSEGS];
 
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
@@ -27,12 +28,12 @@
   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
 
-  // Map cpu and proc -- these are private per cpu.
+  // Map cpu, and curproc
   c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
 
   lgdt(c->gdt, sizeof(c->gdt));
   loadgs(SEG_KCPU << 3);
-
+  
   // Initialize cpu-local storage.
   cpu = c;
   proc = 0;
@@ -49,16 +50,16 @@
 
   pde = &pgdir[PDX(va)];
   if(*pde & PTE_P){
-    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+    pgtab = (pte_t*)p2v(PTE_ADDR(*pde));
   } else {
     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
       return 0;
     // Make sure all those PTE_P bits are zero.
     memset(pgtab, 0, PGSIZE);
     // The permissions here are overly generous, but they can
-    // be further restricted by the permissions in the page table
+    // be further restricted by the permissions in the page table 
     // entries, if necessary.
-    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+    *pde = v2p(pgtab) | PTE_P | PTE_W | PTE_U;
   }
   return &pgtab[PTX(va)];
 }
@@ -71,7 +72,7 @@
 {
   char *a, *last;
   pte_t *pte;
-
+  
   a = (char*)PGROUNDDOWN((uint)va);
   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
   for(;;){
@@ -93,7 +94,7 @@
 // current process's page table during system calls and interrupts;
 // page protection bits prevent user code from using the kernel's
 // mappings.
-//
+// 
 // setupkvm() and exec() set up every page table like this:
 //
 //   0..KERNBASE: user memory (text+data+stack+heap), mapped to
@@ -101,7 +102,7 @@
 //   KERNBASE..KERNBASE+EXTMEM: mapped to 0..EXTMEM (for I/O space)
 //   KERNBASE+EXTMEM..data: mapped to EXTMEM..V2P(data)
 //                for the kernel's instructions and r/o data
-//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP,
+//   data..KERNBASE+PHYSTOP: mapped to V2P(data)..PHYSTOP, 
 //                                  rw data + free physical memory
 //   0xfe000000..0: mapped direct (devices such as ioapic)
 //
@@ -133,10 +134,10 @@
   if((pgdir = (pde_t*)kalloc()) == 0)
     return 0;
   memset(pgdir, 0, PGSIZE);
-  if (P2V(PHYSTOP) > (void*)DEVSPACE)
+  if (p2v(PHYSTOP) > (void*)DEVSPACE)
     panic("PHYSTOP too high");
   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
-    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
+    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start, 
                 (uint)k->phys_start, k->perm) < 0)
       return 0;
   return pgdir;
@@ -156,7 +157,7 @@
 void
 switchkvm(void)
 {
-  lcr3(V2P(kpgdir));   // switch to the kernel page table
+  lcr3(v2p(kpgdir));   // switch to the kernel page table
 }
 
 // Switch TSS and h/w page table to correspond to process p.
@@ -168,13 +169,10 @@
   cpu->gdt[SEG_TSS].s = 0;
   cpu->ts.ss0 = SEG_KDATA << 3;
   cpu->ts.esp0 = (uint)proc->kstack + KSTACKSIZE;
-  // setting IOPL=0 in eflags *and* iomb beyond the tss segment limit
-  // forbids I/O instructions (e.g., inb and outb) from user space
-  cpu->ts.iomb = (ushort) 0xFFFF;
   ltr(SEG_TSS << 3);
   if(p->pgdir == 0)
     panic("switchuvm: no pgdir");
-  lcr3(V2P(p->pgdir));  // switch to process's address space
+  lcr3(v2p(p->pgdir));  // switch to new address space
   popcli();
 }
 
@@ -184,12 +182,12 @@
 inituvm(pde_t *pgdir, char *init, uint sz)
 {
   char *mem;
-
+  
   if(sz >= PGSIZE)
     panic("inituvm: more than a page");
   mem = kalloc();
   memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+  mappages(pgdir, 0, PGSIZE, v2p(mem), PTE_W|PTE_U);
   memmove(mem, init, sz);
 }
 
@@ -211,7 +209,7 @@
       n = sz - i;
     else
       n = PGSIZE;
-    if(readi(ip, P2V(pa), offset+i, n) != n)
+    if(readi(ip, p2v(pa), offset+i, n) != n)
       return -1;
   }
   return 0;
@@ -239,12 +237,7 @@
       return 0;
     }
     memset(mem, 0, PGSIZE);
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
-      cprintf("allocuvm out of memory (2)\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      kfree(mem);
-      return 0;
-    }
+    mappages(pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);
   }
   return newsz;
 }
@@ -271,7 +264,7 @@
       pa = PTE_ADDR(*pte);
       if(pa == 0)
         panic("kfree");
-      char *v = P2V(pa);
+      char *v = p2v(pa);
       kfree(v);
       *pte = 0;
     }
@@ -291,7 +284,7 @@
   deallocuvm(pgdir, KERNBASE, 0);
   for(i = 0; i < NPDENTRIES; i++){
     if(pgdir[i] & PTE_P){
-      char * v = P2V(PTE_ADDR(pgdir[i]));
+      char * v = p2v(PTE_ADDR(pgdir[i]));
       kfree(v);
     }
   }
@@ -332,8 +325,8 @@
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
       goto bad;
-    memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
+    memmove(mem, (char*)p2v(pa), PGSIZE);
+    if(mappages(d, (void*)i, PGSIZE, v2p(mem), flags) < 0)
       goto bad;
   }
   return d;
@@ -355,7 +348,7 @@
     return 0;
   if((*pte & PTE_U) == 0)
     return 0;
-  return (char*)P2V(PTE_ADDR(*pte));
+  return (char*)p2v(PTE_ADDR(*pte));
 }
 
 // Copy len bytes from p to user address va in page table pgdir.
diff -ruN xv6-orig/x86.h xv6-public/x86.h
--- xv6-orig/x86.h	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/x86.h	2016-09-25 15:51:45.659817075 +0530
@@ -121,7 +121,7 @@
 xchg(volatile uint *addr, uint newval)
 {
   uint result;
-
+  
   // The + in "+m" denotes a read-modify-write operand.
   asm volatile("lock; xchgl %0, %1" :
                "+m" (*addr), "=a" (result) :
@@ -139,7 +139,7 @@
 }
 
 static inline void
-lcr3(uint val)
+lcr3(uint val) 
 {
   asm volatile("movl %0,%%cr3" : : "r" (val));
 }
diff -ruN xv6-orig/zombie.c xv6-public/zombie.c
--- xv6-orig/zombie.c	2016-09-25 21:09:53.615296061 +0530
+++ xv6-public/zombie.c	2016-09-25 15:51:45.659817075 +0530
@@ -1,4 +1,4 @@
-// Create a zombie process that
+// Create a zombie process that 
 // must be reparented at exit.
 
 #include "types.h"
