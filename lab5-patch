Only in /home/rganvir/github/xv6-public/: .cvsignore
diff -crB /home/rganvir/github/xv6-public/defs.h /home/rganvir/github/halfForce/lab5/xv6-public/defs.h
*** /home/rganvir/github/xv6-public/defs.h	2016-07-20 14:18:26.113200654 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/defs.h	2016-09-25 17:54:12.571616538 +0530
***************
*** 118,123 ****
--- 118,124 ----
  int             wait(void);
  void            wakeup(void*);
  void            yield(void);
+ int             setprio(int);
  
  // swtch.S
  void            swtch(struct context**, struct context*);
Only in /home/rganvir/github/xv6-public/: .dir-locals.el
Only in /home/rganvir/github/xv6-public/: fmt
Only in /home/rganvir/github/xv6-public/: .gdbinit.tmpl
Only in /home/rganvir/github/halfForce/lab5/xv6-public/: getsize.c
Only in /home/rganvir/github/xv6-public/: .git
Only in /home/rganvir/github/xv6-public/: .gitignore
Only in /home/rganvir/github/xv6-public/: LucidaSans-Typewriter83~
diff -crB /home/rganvir/github/xv6-public/Makefile /home/rganvir/github/halfForce/lab5/xv6-public/Makefile
*** /home/rganvir/github/xv6-public/Makefile	2016-07-20 14:18:26.109200616 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/Makefile	2016-09-25 19:34:38.431452059 +0530
***************
*** 172,177 ****
--- 172,179 ----
  	_usertests\
  	_wc\
  	_zombie\
+ 	_getsize\
+ 	_testschd\
  
  fs.img: mkfs README $(UPROGS)
  	./mkfs fs.img README $(UPROGS)
***************
*** 185,190 ****
--- 187,195 ----
  	.gdbinit \
  	$(UPROGS)
  
+ simulate:
+ 	qemu-system-i386 -serial mon:stdio -hdb fs.img xv6.img -smp cores=4 -m 512
+ 
  # make a printout
  FILES = $(shell grep -v '^\#' runoff.list)
  PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)
***************
*** 239,246 ****
  # check in that version.
  
  EXTRA=\
! 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
! 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
  	printf.c umalloc.c\
  	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
  	.gdbinit.tmpl gdbutil\
--- 244,251 ----
  # check in that version.
  
  EXTRA=\
! 	mkfs.c ulib.c user.h cat.c getsize.c echo.c forktest.c grep.c kill.c\
! 	ln.c ls.c mkdir.c rm.c stressfs.c testschd.c usertests.c wc.c zombie.c\
  	printf.c umalloc.c\
  	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
  	.gdbinit.tmpl gdbutil\
diff -crB /home/rganvir/github/xv6-public/proc.c /home/rganvir/github/halfForce/lab5/xv6-public/proc.c
*** /home/rganvir/github/xv6-public/proc.c	2016-09-25 18:10:44.651589459 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/proc.c	2016-09-25 19:29:50.091459930 +0530
***************
*** 38,45 ****
    char *sp;
  
    acquire(&ptable.lock);
!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
!     if(p->state == UNUSED)
        goto found;
    release(&ptable.lock);
    return 0;
--- 38,45 ----
    char *sp;
  
    acquire(&ptable.lock);
!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
!     if (p->state == UNUSED)
        goto found;
    release(&ptable.lock);
    return 0;
***************
*** 50,73 ****
    release(&ptable.lock);
  
    // Allocate kernel stack.
!   if((p->kstack = kalloc()) == 0){
      p->state = UNUSED;
      return 0;
    }
    sp = p->kstack + KSTACKSIZE;
!   
    // Leave room for trap frame.
!   sp -= sizeof *p->tf;
    p->tf = (struct trapframe*)sp;
!   
    // Set up new context to start executing at forkret,
    // which returns to trapret.
    sp -= 4;
    *(uint*)sp = (uint)trapret;
  
!   sp -= sizeof *p->context;
    p->context = (struct context*)sp;
!   memset(p->context, 0, sizeof *p->context);
    p->context->eip = (uint)forkret;
  
    return p;
--- 50,73 ----
    release(&ptable.lock);
  
    // Allocate kernel stack.
!   if ((p->kstack = kalloc()) == 0) {
      p->state = UNUSED;
      return 0;
    }
    sp = p->kstack + KSTACKSIZE;
! 
    // Leave room for trap frame.
!   sp -= sizeof * p->tf;
    p->tf = (struct trapframe*)sp;
! 
    // Set up new context to start executing at forkret,
    // which returns to trapret.
    sp -= 4;
    *(uint*)sp = (uint)trapret;
  
!   sp -= sizeof * p->context;
    p->context = (struct context*)sp;
!   memset(p->context, 0, sizeof * p->context);
    p->context->eip = (uint)forkret;
  
    return p;
***************
*** 80,89 ****
  {
    struct proc *p;
    extern char _binary_initcode_start[], _binary_initcode_size[];
!   
    p = allocproc();
    initproc = p;
!   if((p->pgdir = setupkvm()) == 0)
      panic("userinit: out of memory?");
    inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
    p->sz = PGSIZE;
--- 80,89 ----
  {
    struct proc *p;
    extern char _binary_initcode_start[], _binary_initcode_size[];
! 
    p = allocproc();
    initproc = p;
!   if ((p->pgdir = setupkvm()) == 0)
      panic("userinit: out of memory?");
    inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
    p->sz = PGSIZE;
***************
*** 100,105 ****
--- 100,108 ----
    p->cwd = namei("/");
  
    p->state = RUNNABLE;
+ 
+   p->priority = 1 ;
+ 
  }
  
  // Grow current process's memory by n bytes.
***************
*** 108,120 ****
  growproc(int n)
  {
    uint sz;
!   
    sz = proc->sz;
!   if(n > 0){
!     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
        return -1;
!   } else if(n < 0){
!     if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
        return -1;
    }
    proc->sz = sz;
--- 111,123 ----
  growproc(int n)
  {
    uint sz;
! 
    sz = proc->sz;
!   if (n > 0) {
!     if ((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
        return -1;
!   } else if (n < 0) {
!     if ((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
        return -1;
    }
    proc->sz = sz;
***************
*** 132,142 ****
    struct proc *np;
  
    // Allocate process.
!   if((np = allocproc()) == 0)
      return -1;
  
    // Copy process state from p.
!   if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
      kfree(np->kstack);
      np->kstack = 0;
      np->state = UNUSED;
--- 135,145 ----
    struct proc *np;
  
    // Allocate process.
!   if ((np = allocproc()) == 0)
      return -1;
  
    // Copy process state from p.
!   if ((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0) {
      kfree(np->kstack);
      np->kstack = 0;
      np->state = UNUSED;
***************
*** 146,168 ****
    np->parent = proc;
    *np->tf = *proc->tf;
  
    // Clear %eax so that fork returns 0 in the child.
    np->tf->eax = 0;
  
!   for(i = 0; i < NOFILE; i++)
!     if(proc->ofile[i])
        np->ofile[i] = filedup(proc->ofile[i]);
    np->cwd = idup(proc->cwd);
  
    safestrcpy(np->name, proc->name, sizeof(proc->name));
!  
    pid = np->pid;
  
    // lock to force the compiler to emit the np->state write last.
    acquire(&ptable.lock);
    np->state = RUNNABLE;
    release(&ptable.lock);
!   
    return pid;
  }
  
--- 149,174 ----
    np->parent = proc;
    *np->tf = *proc->tf;
  
+   //change priority here
+   np->priority = proc->priority;
+ 
    // Clear %eax so that fork returns 0 in the child.
    np->tf->eax = 0;
  
!   for (i = 0; i < NOFILE; i++)
!     if (proc->ofile[i])
        np->ofile[i] = filedup(proc->ofile[i]);
    np->cwd = idup(proc->cwd);
  
    safestrcpy(np->name, proc->name, sizeof(proc->name));
! 
    pid = np->pid;
  
    // lock to force the compiler to emit the np->state write last.
    acquire(&ptable.lock);
    np->state = RUNNABLE;
    release(&ptable.lock);
! 
    return pid;
  }
  
***************
*** 175,186 ****
    struct proc *p;
    int fd;
  
!   if(proc == initproc)
      panic("init exiting");
  
    // Close all open files.
!   for(fd = 0; fd < NOFILE; fd++){
!     if(proc->ofile[fd]){
        fileclose(proc->ofile[fd]);
        proc->ofile[fd] = 0;
      }
--- 181,192 ----
    struct proc *p;
    int fd;
  
!   if (proc == initproc)
      panic("init exiting");
  
    // Close all open files.
!   for (fd = 0; fd < NOFILE; fd++) {
!     if (proc->ofile[fd]) {
        fileclose(proc->ofile[fd]);
        proc->ofile[fd] = 0;
      }
***************
*** 197,206 ****
    wakeup1(proc->parent);
  
    // Pass abandoned children to init.
!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
!     if(p->parent == proc){
        p->parent = initproc;
!       if(p->state == ZOMBIE)
          wakeup1(initproc);
      }
    }
--- 203,212 ----
    wakeup1(proc->parent);
  
    // Pass abandoned children to init.
!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
!     if (p->parent == proc) {
        p->parent = initproc;
!       if (p->state == ZOMBIE)
          wakeup1(initproc);
      }
    }
***************
*** 220,233 ****
    int havekids, pid;
  
    acquire(&ptable.lock);
!   for(;;){
      // Scan through table looking for zombie children.
      havekids = 0;
!     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
!       if(p->parent != proc)
          continue;
        havekids = 1;
!       if(p->state == ZOMBIE){
          // Found one.
          pid = p->pid;
          kfree(p->kstack);
--- 226,239 ----
    int havekids, pid;
  
    acquire(&ptable.lock);
!   for (;;) {
      // Scan through table looking for zombie children.
      havekids = 0;
!     for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
!       if (p->parent != proc)
          continue;
        havekids = 1;
!       if (p->state == ZOMBIE) {
          // Found one.
          pid = p->pid;
          kfree(p->kstack);
***************
*** 244,250 ****
      }
  
      // No point waiting if we don't have any children.
!     if(!havekids || proc->killed){
        release(&ptable.lock);
        return -1;
      }
--- 250,256 ----
      }
  
      // No point waiting if we don't have any children.
!     if (!havekids || proc->killed) {
        release(&ptable.lock);
        return -1;
      }
***************
*** 258,295 ****
  // Per-CPU process scheduler.
  // Each CPU calls scheduler() after setting itself up.
  // Scheduler never returns.  It loops, doing:
! //  - choose a process to run
  //  - swtch to start running that process
  //  - eventually that process transfers control
  //      via swtch back to the scheduler.
  void
  scheduler(void)
  {
!   struct proc *p;
  
!   for(;;){
      // Enable interrupts on this processor.
      sti();
  
!     // Loop over process table looking for process to run.
      acquire(&ptable.lock);
!     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
!       if(p->state != RUNNABLE)
          continue;
! 
!       // Switch to chosen process.  It is the process's job
!       // to release ptable.lock and then reacquire it
!       // before jumping back to us.
!       proc = p;
!       switchuvm(p);
!       p->state = RUNNING;
!       swtch(&cpu->scheduler, proc->context);
!       switchkvm();
! 
!       // Process is done running for now.
!       // It should have changed its p->state before coming back.
!       proc = 0;
      }
      release(&ptable.lock);
  
    }
--- 264,316 ----
  // Per-CPU process scheduler.
  // Each CPU calls scheduler() after setting itself up.
  // Scheduler never returns.  It loops, doing:
! //  - choose process with maximum priority among RUNNABLE processes
  //  - swtch to start running that process
  //  - eventually that process transfers control
  //      via swtch back to the scheduler.
  void
  scheduler(void)
  {
!   struct proc *p, *f;
  
!   for (;;) {
      // Enable interrupts on this processor.
      sti();
  
!     int maxp = 0, first = 1;
!     // Loop over process table looking for pfirstrocess to run.
      acquire(&ptable.lock);
!     for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
!       if (p->state != RUNNABLE)
          continue;
!       else {
!         if (first) {
!           f = p;
!           maxp = p->priority;
!           first = 0;
!           continue;
!         }
!         if (p->priority > maxp ) {
!           f = p;
!           maxp = p->priority;
!         }
!       }
      }
+ 
+     //cprintf("Scheduler here !\n New proc pid %d priority %d.", f->pid, f->priority );
+     // Switch to chosen process.  It is the process's job
+     // to release ptable.lock and then reacquire it
+     // before jumping back to us.
+ 
+     proc = f;
+     switchuvm(f);
+     f->state = RUNNING;
+     swtch(&cpu->scheduler, proc->context);
+     switchkvm();
+ 
+     // Process is done running for now.
+     // It should have changed its p->state before coming back.
+     proc = 0;
      release(&ptable.lock);
  
    }
***************
*** 302,314 ****
  {
    int intena;
  
!   if(!holding(&ptable.lock))
      panic("sched ptable.lock");
!   if(cpu->ncli != 1)
      panic("sched locks");
!   if(proc->state == RUNNING)
      panic("sched running");
!   if(readeflags()&FL_IF)
      panic("sched interruptible");
    intena = cpu->intena;
    swtch(&proc->context, cpu->scheduler);
--- 323,335 ----
  {
    int intena;
  
!   if (!holding(&ptable.lock))
      panic("sched ptable.lock");
!   if (cpu->ncli != 1)
      panic("sched locks");
!   if (proc->state == RUNNING)
      panic("sched running");
!   if (readeflags()&FL_IF)
      panic("sched interruptible");
    intena = cpu->intena;
    swtch(&proc->context, cpu->scheduler);
***************
*** 336,348 ****
  
    if (first) {
      // Some initialization functions must be run in the context
!     // of a regular process (e.g., they call sleep), and thus cannot 
      // be run from main().
      first = 0;
      iinit(ROOTDEV);
      initlog(ROOTDEV);
    }
!   
    // Return to "caller", actually trapret (see allocproc).
  }
  
--- 357,369 ----
  
    if (first) {
      // Some initialization functions must be run in the context
!     // of a regular process (e.g., they call sleep), and thus cannot
      // be run from main().
      first = 0;
      iinit(ROOTDEV);
      initlog(ROOTDEV);
    }
! 
    // Return to "caller", actually trapret (see allocproc).
  }
  
***************
*** 351,360 ****
  void
  sleep(void *chan, struct spinlock *lk)
  {
!   if(proc == 0)
      panic("sleep");
  
!   if(lk == 0)
      panic("sleep without lk");
  
    // Must acquire ptable.lock in order to
--- 372,381 ----
  void
  sleep(void *chan, struct spinlock *lk)
  {
!   if (proc == 0)
      panic("sleep");
  
!   if (lk == 0)
      panic("sleep without lk");
  
    // Must acquire ptable.lock in order to
***************
*** 363,369 ****
    // guaranteed that we won't miss any wakeup
    // (wakeup runs with ptable.lock locked),
    // so it's okay to release lk.
!   if(lk != &ptable.lock){  //DOC: sleeplock0
      acquire(&ptable.lock);  //DOC: sleeplock1
      release(lk);
    }
--- 384,390 ----
    // guaranteed that we won't miss any wakeup
    // (wakeup runs with ptable.lock locked),
    // so it's okay to release lk.
!   if (lk != &ptable.lock) { //DOC: sleeplock0
      acquire(&ptable.lock);  //DOC: sleeplock1
      release(lk);
    }
***************
*** 377,383 ****
    proc->chan = 0;
  
    // Reacquire original lock.
!   if(lk != &ptable.lock){  //DOC: sleeplock2
      release(&ptable.lock);
      acquire(lk);
    }
--- 398,404 ----
    proc->chan = 0;
  
    // Reacquire original lock.
!   if (lk != &ptable.lock) { //DOC: sleeplock2
      release(&ptable.lock);
      acquire(lk);
    }
***************
*** 391,398 ****
  {
    struct proc *p;
  
!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
!     if(p->state == SLEEPING && p->chan == chan)
        p->state = RUNNABLE;
  }
  
--- 412,419 ----
  {
    struct proc *p;
  
!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++)
!     if (p->state == SLEEPING && p->chan == chan)
        p->state = RUNNABLE;
  }
  
***************
*** 414,424 ****
    struct proc *p;
  
    acquire(&ptable.lock);
!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
!     if(p->pid == pid){
        p->killed = 1;
        // Wake process from sleep if necessary.
!       if(p->state == SLEEPING)
          p->state = RUNNABLE;
        release(&ptable.lock);
        return 0;
--- 435,445 ----
    struct proc *p;
  
    acquire(&ptable.lock);
!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
!     if (p->pid == pid) {
        p->killed = 1;
        // Wake process from sleep if necessary.
!       if (p->state == SLEEPING)
          p->state = RUNNABLE;
        release(&ptable.lock);
        return 0;
***************
*** 436,466 ****
  procdump(void)
  {
    static char *states[] = {
!   [UNUSED]    "unused",
!   [EMBRYO]    "embryo",
!   [SLEEPING]  "sleep ",
!   [RUNNABLE]  "runble",
!   [RUNNING]   "run   ",
!   [ZOMBIE]    "zombie"
    };
    int i;
    struct proc *p;
    char *state;
    uint pc[10];
!   
!   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
!     if(p->state == UNUSED)
        continue;
!     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
        state = states[p->state];
      else
        state = "???";
      cprintf("%d %s %s", p->pid, state, p->name);
!     if(p->state == SLEEPING){
!       getcallerpcs((uint*)p->context->ebp+2, pc);
!       for(i=0; i<10 && pc[i] != 0; i++)
          cprintf(" %p", pc[i]);
      }
      cprintf("\n");
    }
  }
--- 457,497 ----
  procdump(void)
  {
    static char *states[] = {
!     [UNUSED]    "unused",
!     [EMBRYO]    "embryo",
!     [SLEEPING]  "sleep ",
!     [RUNNABLE]  "runble",
!     [RUNNING]   "run   ",
!     [ZOMBIE]    "zombie"
    };
    int i;
    struct proc *p;
    char *state;
    uint pc[10];
! 
!   for (p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
!     if (p->state == UNUSED)
        continue;
!     if (p->state >= 0 && p->state < NELEM(states) && states[p->state])
        state = states[p->state];
      else
        state = "???";
      cprintf("%d %s %s", p->pid, state, p->name);
!     if (p->state == SLEEPING) {
!       getcallerpcs((uint*)p->context->ebp + 2, pc);
!       for (i = 0; i < 10 && pc[i] != 0; i++)
          cprintf(" %p", pc[i]);
      }
      cprintf("\n");
    }
  }
+ 
+ int
+ setprio(int prio){
+ 
+   acquire(&ptable.lock);
+   proc->priority = prio;
+   release(&ptable.lock);
+   
+   return 0;
+ }
diff -crB /home/rganvir/github/xv6-public/proc.h /home/rganvir/github/halfForce/lab5/xv6-public/proc.h
*** /home/rganvir/github/xv6-public/proc.h	2016-07-20 14:18:26.113200654 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/proc.h	2016-09-25 15:51:45.655817076 +0530
***************
*** 66,71 ****
--- 66,72 ----
    struct file *ofile[NOFILE];  // Open files
    struct inode *cwd;           // Current directory
    char name[16];               // Process name (debugging)
+   int priority;                // priority of process  
  };
  
  // Process memory is laid out contiguously, low addresses first:
diff -crB /home/rganvir/github/xv6-public/syscall.c /home/rganvir/github/halfForce/lab5/xv6-public/syscall.c
*** /home/rganvir/github/xv6-public/syscall.c	2016-09-21 02:07:35.524385492 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/syscall.c	2016-09-25 17:26:04.559662613 +0530
***************
*** 98,103 ****
--- 98,106 ----
  extern int sys_wait(void);
  extern int sys_write(void);
  extern int sys_uptime(void);
+ extern int sys_getppid(void);
+ extern int sys_setprio(void);
+ extern int sys_getprio(void);
  
  static int (*syscalls[])(void) = {
  [SYS_fork]    sys_fork,
***************
*** 121,126 ****
--- 124,132 ----
  [SYS_link]    sys_link,
  [SYS_mkdir]   sys_mkdir,
  [SYS_close]   sys_close,
+ [SYS_getppid]   sys_getppid,
+ [SYS_setprio]   sys_setprio,
+ [SYS_getprio]   sys_getprio,
  };
  
  void
diff -crB /home/rganvir/github/xv6-public/syscall.h /home/rganvir/github/halfForce/lab5/xv6-public/syscall.h
*** /home/rganvir/github/xv6-public/syscall.h	2016-09-21 02:07:36.452385518 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/syscall.h	2016-09-25 17:11:44.435686091 +0530
***************
*** 20,22 ****
--- 20,25 ----
  #define SYS_link   19
  #define SYS_mkdir  20
  #define SYS_close  21
+ #define SYS_getppid  22
+ #define SYS_getprio  23
+ #define SYS_setprio  24
diff -crB /home/rganvir/github/xv6-public/sysproc.c /home/rganvir/github/halfForce/lab5/xv6-public/sysproc.c
*** /home/rganvir/github/xv6-public/sysproc.c	2016-07-20 14:18:26.117200692 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/sysproc.c	2016-09-25 17:54:59.463615258 +0530
***************
*** 89,91 ****
--- 89,117 ----
    release(&tickslock);
    return xticks;
  }
+ 
+ 
+ //get size of current process
+ int
+ sys_getppid(void)
+ {
+   return proc->parent->pid;
+ }
+ 
+ // set priority of prcess as n
+ int
+ sys_setprio(void){
+ 
+   int prio;
+   if(argint(0, &prio) < 0)
+     return -1;
+   return setprio(prio);
+ }
+ 
+ // get priority of process
+ int
+ sys_getprio(void){
+ 
+     return proc->priority;
+ }
+ 
Only in /home/rganvir/github/halfForce/lab5/xv6-public/: testschd.c
diff -crB /home/rganvir/github/xv6-public/user.h /home/rganvir/github/halfForce/lab5/xv6-public/user.h
*** /home/rganvir/github/xv6-public/user.h	2016-07-20 14:18:26.117200692 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/user.h	2016-09-25 17:26:20.075662190 +0530
***************
*** 23,28 ****
--- 23,32 ----
  char* sbrk(int);
  int sleep(int);
  int uptime(void);
+ int getppid(void);
+ int setprio(int);
+ int getprio(void);
+ 
  
  // ulib.c
  int stat(char*, struct stat*);
diff -crB /home/rganvir/github/xv6-public/usys.S /home/rganvir/github/halfForce/lab5/xv6-public/usys.S
*** /home/rganvir/github/xv6-public/usys.S	2016-07-20 14:18:26.117200692 +0530
--- /home/rganvir/github/halfForce/lab5/xv6-public/usys.S	2016-09-25 17:15:07.111680558 +0530
***************
*** 29,31 ****
--- 29,35 ----
  SYSCALL(sbrk)
  SYSCALL(sleep)
  SYSCALL(uptime)
+ SYSCALL(getppid)
+ SYSCALL(setprio)
+ SYSCALL(getprio)
+ 
Only in /home/rganvir/github/xv6-public/: xv6.pdf
